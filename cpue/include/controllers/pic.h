#pragma once

#include <optional>
#include <bitset>
#include <mutex>

#include "common.h"
#include "forward.h"
#include "interrupts.h"
#include "address.h"

namespace CPUE {


/**
 * Programmable Interrupt Controller
 *
 * NOTE: WE CURRENTLY DON'T SUPPORT PIC
 *
 *
 * Is only responsible for interrupts generated by external devices such as
 *  - watchdog timers (although some watchdogs can also use the NMI pin and bypass the PIC)
 *  - keyboards
 *  - hard drives
 *  - etc.
 *
 *
 * PICs typically have a common set of registers:
 *  - interrupt request register (IRR),
 *  - in-service register (ISR),
 *  - and interrupt mask register (IMR).
 * The IRR specifies which interrupts are pending acknowledgement.
 * The ISR register specifies which interrupts have been acknowledged, but are still waiting for an end of interrupt (EOI).
 * The IMR specifies which interrupts are to be ignored and not acknowledged.
 * A simple register schema such as this allows up to two distinct interrupt requests to be outstanding at one time,
 * one waiting for acknowledgement, and one waiting for EOI.
 *
 * NOTE: The masking functionality is integrated into the interrupt controller, so masked interrupts do not reach the CPU at all.
 *
 * NOTE: By design PIC won't raise another interrupt until the CPU acknowledged the current interrupt.
 *
 * NOTE:
 * Once the interrupt is acknowledged by the CPU the interrupt controller can request another interrupt,
 * regardless if the CPU finished handled the previous interrupt or not.
 * Thus, depending on how the OS controls the CPU it is possible to have nested interrupts.
 *
 * When a device connected to one of the PIC's IRQ lines needs CPU attention the following flow happens:
 * 1. When the PIC receives an unmasked interrupt from a device (PIC interrupts
 *    are edge-triggered with high pin polarity), it sets the corresponding bit in its
 *    IRR (interrupt request register)
 * 2. The IRQ is dispatched to the CPU
 *    2.1 PIC converts the IRQ into a vector number and writes it to a port for CPU to read
 *    2.2 PIC raises an interrupt on CPU INTR pin
 *    2.3 PIC waits for CPU to acknowledge an interrupt before raising another interrupt
 * 3. The CPU acknowledges the IRQ.
 * 4. The PIC sets the corresponding bit in its ISR (in-service register) and clears the
 *    previously set bit in the IRR. If the same interrupt occurs again, it can now
 *    be queued a single time in the IRR.
 * 5. When the interrupt is being handled by the OS, it sends an EOI to the PIC,
 *    which clears the corresponding bit in the ISR
 *
 * When an interrupt is acknowledged the highest priority request is determined and its vector placed on
 * the bus. Additionally, a bit of the Interrupt Service register (ISO-7) is set. This bit remains set until the
 * microprocessor issues an End of Interrupt (EOI) command immediately before returning from the
 * service routine, or if AEOI (Automatic End of Interrupt) bit is set, until the trailing edge of the last INTA.
 *
 * To signal that an interrupt is being handled by the software, the interrupt controller receives an EOI (end of interrupt) notice from the OS.
 * -> in our PIC, a single byte write to PIC::MMIO_REG_BASE+0x0 indicates a EOI notice.
 *
 * Most OSes also use CLI/STI to shield itself during a ISR from further Interrupts. With sti;iret; there is also no race condition, cause:
 * Page 3286:
 * > Maskable hardware interrupts remain inhibited on the instruction boundary following an execution of STI.
 * > The inhibition ends after delivery of another event (e.g., exception) or the execution of the next instruction.
 *
 * Most architectures also support interrupt priorities. When this is enabled,
 * it permits interrupt nesting only for those interrupts that have a higher priority than the current priority level.
 * -> we do not support this.
 *
 */



class PICConnectionHandle {
public:
    explicit PICConnectionHandle(u8 pin);
    u8 pin() const { return m_pin; }

private:
    u8 m_pin;
};


class PIC {
public:
    static constexpr PhysicalAddress MMIO_REG_BASE = 0xff00'0000'0000'ff00_pa;
    static constexpr u8 NUM_IRQ_PINS = 8;
    static constexpr u8 IRQ_VEC_BASE = 0xc0;

public:
    explicit PIC(CPU* cpu) : m_cpu(cpu){};
    PIC(PIC const&) = delete;

    std::optional<PICConnectionHandle> request_connection() {
        std::scoped_lock _(m_mutex);
        if (m_next_free_pin >= NUM_IRQ_PINS)
            return {};
        return PICConnectionHandle(m_next_free_pin++);
    }

    void mask_pin(u8 pin);
    void unmask_pin(u8 pin);
    void raise_irq_pin(PICConnectionHandle const& handle);
    void clear_irq_pin(PICConnectionHandle const& handle);

private:
    void process_pending_irqs();
    void init_mmio_registers();
    void received_eoi();

private:
    // NOTE: normally, they would be sent using port I/O -> we only use MMIO
    union ICW4 {
        struct {
            u8 pm : 1; // 1 = 8086/8088 mode (we implement only this mode)
            u8 aeoi : 1; // 1 = Auto-EOI ; 0=Not-Auto-EOI
            u8 bufmode : 2; // Not implemented
            u8 sfnm : 1; // 1=special-fully-nested-mode
            u8 : 3;
        } concrete;
        u8 value;
    };
    // start with pm=1 and aeoi=0
    ICW4 m_icw4 = {.value = 0x1};

private:
    u8 m_next_free_pin = 0;
    std::bitset<NUM_IRQ_PINS> m_imr = 0; // Interrupt-Masking Register
    std::bitset<NUM_IRQ_PINS> m_isr = 0; // In-Service Register
    std::bitset<NUM_IRQ_PINS> m_irr = 0; // In-Request Register

    std::mutex m_mutex;

    CPU* m_cpu = nullptr;
};

}