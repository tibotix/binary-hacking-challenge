
#include "cpu.h"

namespace CPUE {


InterruptRaisedOr<void> CPU::handle_AAA() {
    TODO();
} //	ASCII Adjust After Addition
InterruptRaisedOr<void> CPU::handle_AAD() {
    TODO();
} //	ASCII Adjust AX Before Division
InterruptRaisedOr<void> CPU::handle_AAM() {
    TODO();
} //	ASCII Adjust AX After Multiply
InterruptRaisedOr<void> CPU::handle_AAS() {
    TODO();
} //	ASCII Adjust AL After Subtraction
InterruptRaisedOr<void> CPU::handle_ADC() {
    TODO();
} //	Add With Carry
InterruptRaisedOr<void> CPU::handle_ADCX() {
    TODO();
} //	Unsigned Integer Addition of Two Operands With Carry Flag
InterruptRaisedOr<void> CPU::handle_ADD() {
    TODO();
} //	Add
InterruptRaisedOr<void> CPU::handle_ADDPD() {
    TODO();
} //	Add Packed Double Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_ADDPS() {
    TODO();
} //	Add Packed Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_ADDSD() {
    TODO();
} //	Add Scalar Double Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_ADDSS() {
    TODO();
} //	Add Scalar Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_ADDSUBPD() {
    TODO();
} //	Packed Double Precision Floating-Point Add/Subtract
InterruptRaisedOr<void> CPU::handle_ADDSUBPS() {
    TODO();
} //	Packed Single Precision Floating-Point Add/Subtract
InterruptRaisedOr<void> CPU::handle_ADOX() {
    TODO();
} //	Unsigned Integer Addition of Two Operands With Overflow Flag
InterruptRaisedOr<void> CPU::handle_AESDEC() {
    TODO();
} //	Perform One Round of an AES Decryption Flow
InterruptRaisedOr<void> CPU::handle_AESDEC128KL() {
    TODO();
} //	Perform Ten Rounds of AES Decryption Flow With Key Locker Using 128-BitKey
InterruptRaisedOr<void> CPU::handle_AESDEC256KL() {
    TODO();
} //	Perform 14 Rounds of AES Decryption Flow With Key Locker Using 256-Bit Key
InterruptRaisedOr<void> CPU::handle_AESDECLAST() {
    TODO();
} //	Perform Last Round of an AES Decryption Flow
InterruptRaisedOr<void> CPU::handle_AESDECWIDE128KL() {
    TODO();
} //	Perform Ten Rounds of AES Decryption Flow With Key Locker on 8 BlocksUsing 128-Bit Key
InterruptRaisedOr<void> CPU::handle_AESDECWIDE256KL() {
    TODO();
} //	Perform 14 Rounds of AES Decryption Flow With Key Locker on 8 BlocksUsing 256-Bit Key
InterruptRaisedOr<void> CPU::handle_AESENC() {
    TODO();
} //	Perform One Round of an AES Encryption Flow
InterruptRaisedOr<void> CPU::handle_AESENC128KL() {
    TODO();
} //	Perform Ten Rounds of AES Encryption Flow With Key Locker Using 128-Bit Key
InterruptRaisedOr<void> CPU::handle_AESENC256KL() {
    TODO();
} //	Perform 14 Rounds of AES Encryption Flow With Key Locker Using 256-Bit Key
InterruptRaisedOr<void> CPU::handle_AESENCLAST() {
    TODO();
} //	Perform Last Round of an AES Encryption Flow
InterruptRaisedOr<void> CPU::handle_AESENCWIDE128KL() {
    TODO();
} //	Perform Ten Rounds of AES Encryption Flow With Key Locker on 8 BlocksUsing 128-Bit Key
InterruptRaisedOr<void> CPU::handle_AESENCWIDE256KL() {
    TODO();
} //	Perform 14 Rounds of AES Encryption Flow With Key Locker on 8 BlocksUsing 256-Bit Key
InterruptRaisedOr<void> CPU::handle_AESIMC() {
    TODO();
} //	Perform the AES InvMixColumn Transformation
InterruptRaisedOr<void> CPU::handle_AESKEYGENASSIST() {
    TODO();
} //	AES Round Key Generation Assist
InterruptRaisedOr<void> CPU::handle_AND() {
    TODO();
} //	Logical AND
InterruptRaisedOr<void> CPU::handle_ANDN() {
    TODO();
} //	Logical AND NOT
InterruptRaisedOr<void> CPU::handle_ANDNPD() {
    TODO();
} //	Bitwise Logical AND NOT of Packed Double Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_ANDNPS() {
    TODO();
} //	Bitwise Logical AND NOT of Packed Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_ANDPD() {
    TODO();
} //	Bitwise Logical AND of Packed Double Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_ANDPS() {
    TODO();
} //	Bitwise Logical AND of Packed Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_ARPL() {
    TODO();
} //	Adjust RPL Field of Segment Selector
InterruptRaisedOr<void> CPU::handle_BEXTR() {
    TODO();
} //	Bit Field Extract
InterruptRaisedOr<void> CPU::handle_BLENDPD() {
    TODO();
} //	Blend Packed Double Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_BLENDPS() {
    TODO();
} //	Blend Packed Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_BLENDVPD() {
    TODO();
} //	Variable Blend Packed Double Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_BLENDVPS() {
    TODO();
} //	Variable Blend Packed Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_BLSI() {
    TODO();
} //	Extract Lowest Set Isolated Bit
InterruptRaisedOr<void> CPU::handle_BLSMSK() {
    TODO();
} //	Get Mask Up to Lowest Set Bit
InterruptRaisedOr<void> CPU::handle_BLSR() {
    TODO();
} //	Reset Lowest Set Bit
InterruptRaisedOr<void> CPU::handle_BNDCL() {
    TODO();
} //	Check Lower Bound
InterruptRaisedOr<void> CPU::handle_BNDCN() {
    TODO();
} //	Check Upper Bound
InterruptRaisedOr<void> CPU::handle_BNDCU() {
    TODO();
} //	Check Upper Bound
InterruptRaisedOr<void> CPU::handle_BNDLDX() {
    TODO();
} //	Load Extended Bounds Using Address Translation
InterruptRaisedOr<void> CPU::handle_BNDMK() {
    TODO();
} //	Make Bounds
InterruptRaisedOr<void> CPU::handle_BNDMOV() {
    TODO();
} //	Move Bounds
InterruptRaisedOr<void> CPU::handle_BNDSTX() {
    TODO();
} //	Store Extended Bounds Using Address Translation
InterruptRaisedOr<void> CPU::handle_BOUND() {
    TODO("Only handle interrupt if out of bounds");
    static Interrupt i = {
        .vector = 5,
        .type = InterruptType::SOFTWARE_INTERRUPT,
        .iclass = InterruptClass::BENIGN,
    };
    return handle_interrupt(i);
} //	Check Array Index Against Bounds
InterruptRaisedOr<void> CPU::handle_BSF() {
    TODO();
} //	Bit Scan Forward
InterruptRaisedOr<void> CPU::handle_BSR() {
    TODO();
} //	Bit Scan Reverse
InterruptRaisedOr<void> CPU::handle_BSWAP() {
    TODO();
} //	Byte Swap
InterruptRaisedOr<void> CPU::handle_BT() {
    TODO();
} //	Bit Test
InterruptRaisedOr<void> CPU::handle_BTC() {
    TODO();
} //	Bit Test and Complement
InterruptRaisedOr<void> CPU::handle_BTR() {
    TODO();
} //	Bit Test and Reset
InterruptRaisedOr<void> CPU::handle_BTS() {
    TODO();
} //	Bit Test and Set
InterruptRaisedOr<void> CPU::handle_BZHI() {
    TODO();
} //	Zero High Bits Starting with Specified Bit Position
InterruptRaisedOr<void> CPU::handle_CALL() {
    TODO();
} //	Call Procedure
InterruptRaisedOr<void> CPU::handle_CBW() {
    TODO();
} //	Convert Byte to Word/Convert Word to Doubleword/Convert Doubleword toQuadword
InterruptRaisedOr<void> CPU::handle_CDQ() {
    TODO();
} //	Convert Word to Doubleword/Convert Doubleword to Quadword
InterruptRaisedOr<void> CPU::handle_CDQE() {
    TODO();
} //	Convert Byte to Word/Convert Word to Doubleword/Convert Doubleword toQuadword
InterruptRaisedOr<void> CPU::handle_CLAC() {
    TODO();
} //	Clear AC Flag in EFLAGS Register
InterruptRaisedOr<void> CPU::handle_CLC() {
    TODO();
} //	Clear Carry Flag
InterruptRaisedOr<void> CPU::handle_CLD() {
    TODO();
} //	Clear Direction Flag
InterruptRaisedOr<void> CPU::handle_CLDEMOTE() {
    TODO();
} //	Cache Line Demote
InterruptRaisedOr<void> CPU::handle_CLFLUSH() {
    TODO();
} //	Flush Cache Line
InterruptRaisedOr<void> CPU::handle_CLFLUSHOPT() {
    TODO();
} //	Flush Cache Line Optimized
InterruptRaisedOr<void> CPU::handle_CLI() {
    TODO();
} //	Clear Interrupt Flag
InterruptRaisedOr<void> CPU::handle_CLRSSBSY() {
    TODO();
} //	Clear Busy Flag in a Supervisor Shadow Stack Token
InterruptRaisedOr<void> CPU::handle_CLTS() {
    TODO();
} //	Clear Task-Switched Flag in CR0
InterruptRaisedOr<void> CPU::handle_CLUI() {
    TODO();
} //	Clear User Interrupt Flag
InterruptRaisedOr<void> CPU::handle_CLWB() {
    TODO();
} //	Cache Line Write Back
InterruptRaisedOr<void> CPU::handle_CMC() {
    TODO();
} //	Complement Carry Flag
InterruptRaisedOr<void> CPU::handle_CMOVcc() {
    TODO();
} //	Conditional Move
InterruptRaisedOr<void> CPU::handle_CMP() {
    TODO();
} //	Compare Two Operands
InterruptRaisedOr<void> CPU::handle_CMPPD() {
    TODO();
} //	Compare Packed Double Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_CMPPS() {
    TODO();
} //	Compare Packed Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_CMPS() {
    TODO();
} //	Compare String Operands
InterruptRaisedOr<void> CPU::handle_CMPSB() {
    TODO();
} //	Compare String Operands
InterruptRaisedOr<void> CPU::handle_CMPSD() {
    TODO();
} // (1)	Compare Scalar Double Precision Floating-Point Value
InterruptRaisedOr<void> CPU::handle_CMPSQ() {
    TODO();
} //	Compare String Operands
InterruptRaisedOr<void> CPU::handle_CMPSS() {
    TODO();
} //	Compare Scalar Single Precision Floating-Point Value
InterruptRaisedOr<void> CPU::handle_CMPSW() {
    TODO();
} //	Compare String Operands
InterruptRaisedOr<void> CPU::handle_CMPXCHG() {
    TODO();
} //	Compare and Exchange
InterruptRaisedOr<void> CPU::handle_CMPXCHG16B() {
    TODO();
} //	Compare and Exchange Bytes
InterruptRaisedOr<void> CPU::handle_CMPXCHG8B() {
    TODO();
} //	Compare and Exchange Bytes
InterruptRaisedOr<void> CPU::handle_COMISD() {
    TODO();
} //	Compare Scalar Ordered Double Precision Floating-Point Values and Set EFLAGS
InterruptRaisedOr<void> CPU::handle_COMISS() {
    TODO();
} //	Compare Scalar Ordered Single Precision Floating-Point Values and Set EFLAGS
InterruptRaisedOr<void> CPU::handle_CPUID() {
    TODO();
} //	CPU Identification
InterruptRaisedOr<void> CPU::handle_CQO() {
    TODO();
} //	Convert Word to Doubleword/Convert Doubleword to Quadword
InterruptRaisedOr<void> CPU::handle_CRC32() {
    TODO();
} //	Accumulate CRC32 Value
InterruptRaisedOr<void> CPU::handle_CVTDQ2PD() {
    TODO();
} //	Convert Packed Doubleword Integers to Packed Double Precision Floating-PointValues
InterruptRaisedOr<void> CPU::handle_CVTDQ2PS() {
    TODO();
} //	Convert Packed Doubleword Integers to Packed Single Precision Floating-PointValues
InterruptRaisedOr<void> CPU::handle_CVTPD2DQ() {
    TODO();
} //	Convert Packed Double Precision Floating-Point Values to Packed DoublewordIntegers
InterruptRaisedOr<void> CPU::handle_CVTPD2PI() {
    TODO();
} //	Convert Packed Double Precision Floating-Point Values to Packed Dword Integers
InterruptRaisedOr<void> CPU::handle_CVTPD2PS() {
    TODO();
} //	Convert Packed Double Precision Floating-Point Values to Packed Single PrecisionFloating-Point Values
InterruptRaisedOr<void> CPU::handle_CVTPI2PD() {
    TODO();
} //	Convert Packed Dword Integers to Packed Double Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_CVTPI2PS() {
    TODO();
} //	Convert Packed Dword Integers to Packed Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_CVTPS2DQ() {
    TODO();
} //	Convert Packed Single Precision Floating-Point Values to Packed SignedDoubleword Integer Values
InterruptRaisedOr<void> CPU::handle_CVTPS2PD() {
    TODO();
} //	Convert Packed Single Precision Floating-Point Values to Packed Double PrecisionFloating-Point Values
InterruptRaisedOr<void> CPU::handle_CVTPS2PI() {
    TODO();
} //	Convert Packed Single Precision Floating-Point Values to Packed Dword Integers
InterruptRaisedOr<void> CPU::handle_CVTSD2SI() {
    TODO();
} //	Convert Scalar Double Precision Floating-Point Value to Doubleword Integer
InterruptRaisedOr<void> CPU::handle_CVTSD2SS() {
    TODO();
} //	Convert Scalar Double Precision Floating-Point Value to Scalar Single PrecisionFloating-Point Value
InterruptRaisedOr<void> CPU::handle_CVTSI2SD() {
    TODO();
} //	Convert Doubleword Integer to Scalar Double Precision Floating-Point Value
InterruptRaisedOr<void> CPU::handle_CVTSI2SS() {
    TODO();
} //	Convert Doubleword Integer to Scalar Single Precision Floating-Point Value
InterruptRaisedOr<void> CPU::handle_CVTSS2SD() {
    TODO();
} //	Convert Scalar Single Precision Floating-Point Value to Scalar Double PrecisionFloating-Point Value
InterruptRaisedOr<void> CPU::handle_CVTSS2SI() {
    TODO();
} //	Convert Scalar Single Precision Floating-Point Value to Doubleword Integer
InterruptRaisedOr<void> CPU::handle_CVTTPD2DQ() {
    TODO();
} //	Convert with Truncation Packed Double Precision Floating-Point Values toPacked Doubleword Integers
InterruptRaisedOr<void> CPU::handle_CVTTPD2PI() {
    TODO();
} //	Convert With Truncation Packed Double Precision Floating-Point Values to PackedDword Integers
InterruptRaisedOr<void> CPU::handle_CVTTPS2DQ() {
    TODO();
} //	Convert With Truncation Packed Single Precision Floating-Point Values to PackedSigned Doubleword Integer Values
InterruptRaisedOr<void> CPU::handle_CVTTPS2PI() {
    TODO();
} //	Convert With Truncation Packed Single Precision Floating-Point Values to PackedDword Integers
InterruptRaisedOr<void> CPU::handle_CVTTSD2SI() {
    TODO();
} //	Convert With Truncation Scalar Double Precision Floating-Point Value to SignedInteger
InterruptRaisedOr<void> CPU::handle_CVTTSS2SI() {
    TODO();
} //	Convert With Truncation Scalar Single Precision Floating-Point Value to Integer
InterruptRaisedOr<void> CPU::handle_CWD() {
    TODO();
} //	Convert Word to Doubleword/Convert Doubleword to Quadword
InterruptRaisedOr<void> CPU::handle_CWDE() {
    TODO();
} //	Convert Byte to Word/Convert Word to Doubleword/Convert Doubleword toQuadword
InterruptRaisedOr<void> CPU::handle_DAA() {
    TODO();
} //	Decimal Adjust AL After Addition
InterruptRaisedOr<void> CPU::handle_DAS() {
    TODO();
} //	Decimal Adjust AL After Subtraction
InterruptRaisedOr<void> CPU::handle_DEC() {
    TODO();
} //	Decrement by 1
InterruptRaisedOr<void> CPU::handle_DIV() {
    TODO();
} //	Unsigned Divide
InterruptRaisedOr<void> CPU::handle_DIVPD() {
    TODO();
} //	Divide Packed Double Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_DIVPS() {
    TODO();
} //	Divide Packed Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_DIVSD() {
    TODO();
} //	Divide Scalar Double Precision Floating-Point Value
InterruptRaisedOr<void> CPU::handle_DIVSS() {
    TODO();
} //	Divide Scalar Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_DPPD() {
    TODO();
} //	Dot Product of Packed Double Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_DPPS() {
    TODO();
} //	Dot Product of Packed Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_EMMS() {
    TODO();
} //	Empty MMX Technology State
InterruptRaisedOr<void> CPU::handle_ENCODEKEY128() {
    TODO();
} //	Encode 128-Bit Key With Key Locker
InterruptRaisedOr<void> CPU::handle_ENCODEKEY256() {
    TODO();
} //	Encode 256-Bit Key With Key Locker
InterruptRaisedOr<void> CPU::handle_ENDBR32() {
    TODO();
} //	Terminate an Indirect Branch in 32-bit and Compatibility Mode
InterruptRaisedOr<void> CPU::handle_ENDBR64() {
    TODO();
} //	Terminate an Indirect Branch in 64-bit Mode
InterruptRaisedOr<void> CPU::handle_ENQCMD() {
    TODO();
} //	Enqueue Command
InterruptRaisedOr<void> CPU::handle_ENQCMDS() {
    TODO();
} //	Enqueue Command Supervisor
InterruptRaisedOr<void> CPU::handle_ENTER() {
    TODO();
} //	Make Stack Frame for Procedure Parameters
InterruptRaisedOr<void> CPU::handle_EXTRACTPS() {
    TODO();
} //	Extract Packed Floating-Point Values
InterruptRaisedOr<void> CPU::handle_F2XM1() {
    TODO();
} //	Compute 2x–1
InterruptRaisedOr<void> CPU::handle_FABS() {
    TODO();
} //	Absolute Value
InterruptRaisedOr<void> CPU::handle_FADD() {
    TODO();
} //	Add
InterruptRaisedOr<void> CPU::handle_FADDP() {
    TODO();
} //	Add
InterruptRaisedOr<void> CPU::handle_FBLD() {
    TODO();
} //	Load Binary Coded Decimal
InterruptRaisedOr<void> CPU::handle_FBSTP() {
    TODO();
} //	Store BCD Integer and Pop
InterruptRaisedOr<void> CPU::handle_FCHS() {
    TODO();
} //	Change Sign
InterruptRaisedOr<void> CPU::handle_FCLEX() {
    TODO();
} //	Clear Exceptions
InterruptRaisedOr<void> CPU::handle_FCMOVcc() {
    TODO();
} //	Floating-Point Conditional Move
InterruptRaisedOr<void> CPU::handle_FCOM() {
    TODO();
} //	Compare Floating-Point Values
InterruptRaisedOr<void> CPU::handle_FCOMI() {
    TODO();
} //	Compare Floating-Point Values and Set EFLAGS
InterruptRaisedOr<void> CPU::handle_FCOMIP() {
    TODO();
} //	Compare Floating-Point Values and Set EFLAGS
InterruptRaisedOr<void> CPU::handle_FCOMP() {
    TODO();
} //	Compare Floating-Point Values
InterruptRaisedOr<void> CPU::handle_FCOMPP() {
    TODO();
} //	Compare Floating-Point Values
InterruptRaisedOr<void> CPU::handle_FCOS() {
    TODO();
} //	Cosine
InterruptRaisedOr<void> CPU::handle_FDECSTP() {
    TODO();
} //	Decrement Stack-Top Pointer
InterruptRaisedOr<void> CPU::handle_FDIV() {
    TODO();
} //	Divide
InterruptRaisedOr<void> CPU::handle_FDIVP() {
    TODO();
} //	Divide
InterruptRaisedOr<void> CPU::handle_FDIVR() {
    TODO();
} //	Reverse Divide
InterruptRaisedOr<void> CPU::handle_FDIVRP() {
    TODO();
} //	Reverse Divide
InterruptRaisedOr<void> CPU::handle_FFREE() {
    TODO();
} //	Free Floating-Point Register
InterruptRaisedOr<void> CPU::handle_FIADD() {
    TODO();
} //	Add
InterruptRaisedOr<void> CPU::handle_FICOM() {
    TODO();
} //	Compare Integer
InterruptRaisedOr<void> CPU::handle_FICOMP() {
    TODO();
} //	Compare Integer
InterruptRaisedOr<void> CPU::handle_FIDIV() {
    TODO();
} //	Divide
InterruptRaisedOr<void> CPU::handle_FIDIVR() {
    TODO();
} //	Reverse Divide
InterruptRaisedOr<void> CPU::handle_FILD() {
    TODO();
} //	Load Integer
InterruptRaisedOr<void> CPU::handle_FIMUL() {
    TODO();
} //	Multiply
InterruptRaisedOr<void> CPU::handle_FINCSTP() {
    TODO();
} //	Increment Stack-Top Pointer
InterruptRaisedOr<void> CPU::handle_FINIT() {
    TODO();
} //	Initialize Floating-Point Unit
InterruptRaisedOr<void> CPU::handle_FIST() {
    TODO();
} //	Store Integer
InterruptRaisedOr<void> CPU::handle_FISTP() {
    TODO();
} //	Store Integer
InterruptRaisedOr<void> CPU::handle_FISTTP() {
    TODO();
} //	Store Integer With Truncation
InterruptRaisedOr<void> CPU::handle_FISUB() {
    TODO();
} //	Subtract
InterruptRaisedOr<void> CPU::handle_FISUBR() {
    TODO();
} //	Reverse Subtract
InterruptRaisedOr<void> CPU::handle_FLD() {
    TODO();
} //	Load Floating-Point Value
InterruptRaisedOr<void> CPU::handle_FLD1() {
    TODO();
} //	Load Constant
InterruptRaisedOr<void> CPU::handle_FLDCW() {
    TODO();
} //	Load x87 FPU Control Word
InterruptRaisedOr<void> CPU::handle_FLDENV() {
    TODO();
} //	Load x87 FPU Environment
InterruptRaisedOr<void> CPU::handle_FLDL2E() {
    TODO();
} //	Load Constant
InterruptRaisedOr<void> CPU::handle_FLDL2T() {
    TODO();
} //	Load Constant
InterruptRaisedOr<void> CPU::handle_FLDLG2() {
    TODO();
} //	Load Constant
InterruptRaisedOr<void> CPU::handle_FLDLN2() {
    TODO();
} //	Load Constant
InterruptRaisedOr<void> CPU::handle_FLDPI() {
    TODO();
} //	Load Constant
InterruptRaisedOr<void> CPU::handle_FLDZ() {
    TODO();
} //	Load Constant
InterruptRaisedOr<void> CPU::handle_FMUL() {
    TODO();
} //	Multiply
InterruptRaisedOr<void> CPU::handle_FMULP() {
    TODO();
} //	Multiply
InterruptRaisedOr<void> CPU::handle_FNCLEX() {
    TODO();
} //	Clear Exceptions
InterruptRaisedOr<void> CPU::handle_FNINIT() {
    TODO();
} //	Initialize Floating-Point Unit
InterruptRaisedOr<void> CPU::handle_FNOP() {
    TODO();
} //	No Operation
InterruptRaisedOr<void> CPU::handle_FNSAVE() {
    TODO();
} //	Store x87 FPU State
InterruptRaisedOr<void> CPU::handle_FNSTCW() {
    TODO();
} //	Store x87 FPU Control Word
InterruptRaisedOr<void> CPU::handle_FNSTENV() {
    TODO();
} //	Store x87 FPU Environment
InterruptRaisedOr<void> CPU::handle_FNSTSW() {
    TODO();
} //	Store x87 FPU Status Word
InterruptRaisedOr<void> CPU::handle_FPATAN() {
    TODO();
} //	Partial Arctangent
InterruptRaisedOr<void> CPU::handle_FPREM() {
    TODO();
} //	Partial Remainder
InterruptRaisedOr<void> CPU::handle_FPREM1() {
    TODO();
} //	Partial Remainder
InterruptRaisedOr<void> CPU::handle_FPTAN() {
    TODO();
} //	Partial Tangent
InterruptRaisedOr<void> CPU::handle_FRNDINT() {
    TODO();
} //	Round to Integer
InterruptRaisedOr<void> CPU::handle_FRSTOR() {
    TODO();
} //	Restore x87 FPU State
InterruptRaisedOr<void> CPU::handle_FSAVE() {
    TODO();
} //	Store x87 FPU State
InterruptRaisedOr<void> CPU::handle_FSCALE() {
    TODO();
} //	Scale
InterruptRaisedOr<void> CPU::handle_FSIN() {
    TODO();
} //	Sine
InterruptRaisedOr<void> CPU::handle_FSINCOS() {
    TODO();
} //	Sine and Cosine
InterruptRaisedOr<void> CPU::handle_FSQRT() {
    TODO();
} //	Square Root
InterruptRaisedOr<void> CPU::handle_FST() {
    TODO();
} //	Store Floating-Point Value
InterruptRaisedOr<void> CPU::handle_FSTCW() {
    TODO();
} //	Store x87 FPU Control Word
InterruptRaisedOr<void> CPU::handle_FSTENV() {
    TODO();
} //	Store x87 FPU Environment
InterruptRaisedOr<void> CPU::handle_FSTP() {
    TODO();
} //	Store Floating-Point Value
InterruptRaisedOr<void> CPU::handle_FSTSW() {
    TODO();
} //	Store x87 FPU Status Word
InterruptRaisedOr<void> CPU::handle_FSUB() {
    TODO();
} //	Subtract
InterruptRaisedOr<void> CPU::handle_FSUBP() {
    TODO();
} //	Subtract
InterruptRaisedOr<void> CPU::handle_FSUBR() {
    TODO();
} //	Reverse Subtract
InterruptRaisedOr<void> CPU::handle_FSUBRP() {
    TODO();
} //	Reverse Subtract
InterruptRaisedOr<void> CPU::handle_FTST() {
    TODO();
} //	TEST
InterruptRaisedOr<void> CPU::handle_FUCOM() {
    TODO();
} //	Unordered Compare Floating-Point Values
InterruptRaisedOr<void> CPU::handle_FUCOMI() {
    TODO();
} //	Compare Floating-Point Values and Set EFLAGS
InterruptRaisedOr<void> CPU::handle_FUCOMIP() {
    TODO();
} //	Compare Floating-Point Values and Set EFLAGS
InterruptRaisedOr<void> CPU::handle_FUCOMP() {
    TODO();
} //	Unordered Compare Floating-Point Values
InterruptRaisedOr<void> CPU::handle_FUCOMPP() {
    TODO();
} //	Unordered Compare Floating-Point Values
InterruptRaisedOr<void> CPU::handle_FWAIT() {
    TODO();
} //	Wait
InterruptRaisedOr<void> CPU::handle_FXAM() {
    TODO();
} //	Examine Floating-Point
InterruptRaisedOr<void> CPU::handle_FXCH() {
    TODO();
} //	Exchange Register Contents
InterruptRaisedOr<void> CPU::handle_FXRSTOR() {
    TODO();
} //	Restore x87 FPU, MMX, XMM, and MXCSR State
InterruptRaisedOr<void> CPU::handle_FXSAVE() {
    TODO();
} //	Save x87 FPU, MMX Technology, and SSE State
InterruptRaisedOr<void> CPU::handle_FXTRACT() {
    TODO();
} //	Extract Exponent and Significand
InterruptRaisedOr<void> CPU::handle_FYL2X() {
    TODO();
} //	Compute y ∗ log2x
InterruptRaisedOr<void> CPU::handle_FYL2XP1() {
    TODO();
} //	Compute y ∗ log2(x +1)
InterruptRaisedOr<void> CPU::handle_GF2P8AFFINEINVQB() {
    TODO();
} //	Galois Field Affine Transformation Inverse
InterruptRaisedOr<void> CPU::handle_GF2P8AFFINEQB() {
    TODO();
} //	Galois Field Affine Transformation
InterruptRaisedOr<void> CPU::handle_GF2P8MULB() {
    TODO();
} //	Galois Field Multiply Bytes
InterruptRaisedOr<void> CPU::handle_HADDPD() {
    TODO();
} //	Packed Double Precision Floating-Point Horizontal Add
InterruptRaisedOr<void> CPU::handle_HADDPS() {
    TODO();
} //	Packed Single Precision Floating-Point Horizontal Add
InterruptRaisedOr<void> CPU::handle_HLT() {
    TODO();
} //	Halt
InterruptRaisedOr<void> CPU::handle_HRESET() {
    TODO();
} //	History Reset
InterruptRaisedOr<void> CPU::handle_HSUBPD() {
    TODO();
} //	Packed Double Precision Floating-Point Horizontal Subtract
InterruptRaisedOr<void> CPU::handle_HSUBPS() {
    TODO();
} //	Packed Single Precision Floating-Point Horizontal Subtract
InterruptRaisedOr<void> CPU::handle_IDIV() {
    TODO();
} //	Signed Divide
InterruptRaisedOr<void> CPU::handle_IMUL() {
    TODO();
} //	Signed Multiply
InterruptRaisedOr<void> CPU::handle_IN() {
    TODO();
} //	Input From Port
InterruptRaisedOr<void> CPU::handle_INC() {
    TODO();
} //	Increment by 1
InterruptRaisedOr<void> CPU::handle_INCSSPD() {
    TODO();
} //	Increment Shadow Stack Pointer
InterruptRaisedOr<void> CPU::handle_INCSSPQ() {
    TODO();
} //	Increment Shadow Stack Pointer
InterruptRaisedOr<void> CPU::handle_INS() {
    TODO();
} //	Input from Port to String
InterruptRaisedOr<void> CPU::handle_INSB() {
    TODO();
} //	Input from Port to String
InterruptRaisedOr<void> CPU::handle_INSD() {
    TODO();
} //	Input from Port to String
InterruptRaisedOr<void> CPU::handle_INSERTPS() {
    TODO();
} //	Insert Scalar Single Precision Floating-Point Value
InterruptRaisedOr<void> CPU::handle_INSW() {
    TODO();
} //	Input from Port to String
InterruptRaisedOr<void> CPU::handle_INT() {
    // TODO: increment m_rip, because the return address is the next insn
    Interrupt i = {
        .vector = 0, // TODO: use actual vector
        .type = InterruptType::SOFTWARE_INTERRUPT,
        .iclass = InterruptClass::BENIGN,
    };
    return handle_interrupt(i);
} // 	Call to Interrupt Procedure
InterruptRaisedOr<void> CPU::handle_INT1() {
    static Interrupt i = {
        .vector = 1,
        .type = InterruptType::SOFTWARE_INTERRUPT,
        .iclass = InterruptClass::BENIGN,
    };
    return handle_interrupt(i);
} //	Call to Interrupt Procedure
InterruptRaisedOr<void> CPU::handle_INT3() {
    TODO_NOFAIL("increment rip");
    static Interrupt i = {
        .vector = 3,
        .type = InterruptType::SOFTWARE_INTERRUPT,
        .iclass = InterruptClass::BENIGN,
    };
    return handle_interrupt(i);
} //	Call to Interrupt Procedure
InterruptRaisedOr<void> CPU::handle_INTO() {
    TODO_NOFAIL("increment rip");
    static Interrupt i = {
        .vector = 4,
        .type = InterruptType::SOFTWARE_INTERRUPT,
        .iclass = InterruptClass::BENIGN,
    };
    if (m_rflags.OF) {
        return handle_interrupt(i);
    }
    return {};
} //	Call to Interrupt Procedure
InterruptRaisedOr<void> CPU::handle_INVD() {
    TODO();
} //	Invalidate Internal Caches
InterruptRaisedOr<void> CPU::handle_INVLPG() {
    TODO();
} //	Invalidate TLB Entries
InterruptRaisedOr<void> CPU::handle_INVPCID() {
    TODO();
} //	Invalidate Process-Context Identifier
InterruptRaisedOr<void> CPU::handle_IRET() {
    TODO();
} //	Interrupt Return
InterruptRaisedOr<void> CPU::handle_IRETD() {
    TODO();
} //	Interrupt Return
InterruptRaisedOr<void> CPU::handle_IRETQ() {
    TODO();
} //	Interrupt Return
InterruptRaisedOr<void> CPU::handle_JMP() {
    TODO();
} //	Jump
InterruptRaisedOr<void> CPU::handle_Jcc() {
    TODO();
} //	Jump if Condition Is Met
InterruptRaisedOr<void> CPU::handle_KADDB() {
    TODO();
} //	ADD Two Masks
InterruptRaisedOr<void> CPU::handle_KADDD() {
    TODO();
} //	ADD Two Masks
InterruptRaisedOr<void> CPU::handle_KADDQ() {
    TODO();
} //	ADD Two Masks
InterruptRaisedOr<void> CPU::handle_KADDW() {
    TODO();
} //	ADD Two Masks
InterruptRaisedOr<void> CPU::handle_KANDB() {
    TODO();
} //	Bitwise Logical AND Masks
InterruptRaisedOr<void> CPU::handle_KANDD() {
    TODO();
} //	Bitwise Logical AND Masks
InterruptRaisedOr<void> CPU::handle_KANDNB() {
    TODO();
} //	Bitwise Logical AND NOT Masks
InterruptRaisedOr<void> CPU::handle_KANDND() {
    TODO();
} //	Bitwise Logical AND NOT Masks
InterruptRaisedOr<void> CPU::handle_KANDNQ() {
    TODO();
} //	Bitwise Logical AND NOT Masks
InterruptRaisedOr<void> CPU::handle_KANDNW() {
    TODO();
} //	Bitwise Logical AND NOT Masks
InterruptRaisedOr<void> CPU::handle_KANDQ() {
    TODO();
} //	Bitwise Logical AND Masks
InterruptRaisedOr<void> CPU::handle_KANDW() {
    TODO();
} //	Bitwise Logical AND Masks
InterruptRaisedOr<void> CPU::handle_KMOVB() {
    TODO();
} //	Move From and to Mask Registers
InterruptRaisedOr<void> CPU::handle_KMOVD() {
    TODO();
} //	Move From and to Mask Registers
InterruptRaisedOr<void> CPU::handle_KMOVQ() {
    TODO();
} //	Move From and to Mask Registers
InterruptRaisedOr<void> CPU::handle_KMOVW() {
    TODO();
} //	Move From and to Mask Registers
InterruptRaisedOr<void> CPU::handle_KNOTB() {
    TODO();
} //	NOT Mask Register
InterruptRaisedOr<void> CPU::handle_KNOTD() {
    TODO();
} //	NOT Mask Register
InterruptRaisedOr<void> CPU::handle_KNOTQ() {
    TODO();
} //	NOT Mask Register
InterruptRaisedOr<void> CPU::handle_KNOTW() {
    TODO();
} //	NOT Mask Register
InterruptRaisedOr<void> CPU::handle_KORB() {
    TODO();
} //	Bitwise Logical OR Masks
InterruptRaisedOr<void> CPU::handle_KORD() {
    TODO();
} //	Bitwise Logical OR Masks
InterruptRaisedOr<void> CPU::handle_KORQ() {
    TODO();
} //	Bitwise Logical OR Masks
InterruptRaisedOr<void> CPU::handle_KORTESTB() {
    TODO();
} //	OR Masks and Set Flags
InterruptRaisedOr<void> CPU::handle_KORTESTD() {
    TODO();
} //	OR Masks and Set Flags
InterruptRaisedOr<void> CPU::handle_KORTESTQ() {
    TODO();
} //	OR Masks and Set Flags
InterruptRaisedOr<void> CPU::handle_KORTESTW() {
    TODO();
} //	OR Masks and Set Flags
InterruptRaisedOr<void> CPU::handle_KORW() {
    TODO();
} //	Bitwise Logical OR Masks
InterruptRaisedOr<void> CPU::handle_KSHIFTLB() {
    TODO();
} //	Shift Left Mask Registers
InterruptRaisedOr<void> CPU::handle_KSHIFTLD() {
    TODO();
} //	Shift Left Mask Registers
InterruptRaisedOr<void> CPU::handle_KSHIFTLQ() {
    TODO();
} //	Shift Left Mask Registers
InterruptRaisedOr<void> CPU::handle_KSHIFTLW() {
    TODO();
} //	Shift Left Mask Registers
InterruptRaisedOr<void> CPU::handle_KSHIFTRB() {
    TODO();
} //	Shift Right Mask Registers
InterruptRaisedOr<void> CPU::handle_KSHIFTRD() {
    TODO();
} //	Shift Right Mask Registers
InterruptRaisedOr<void> CPU::handle_KSHIFTRQ() {
    TODO();
} //	Shift Right Mask Registers
InterruptRaisedOr<void> CPU::handle_KSHIFTRW() {
    TODO();
} //	Shift Right Mask Registers
InterruptRaisedOr<void> CPU::handle_KTESTB() {
    TODO();
} //	Packed Bit Test Masks and Set Flags
InterruptRaisedOr<void> CPU::handle_KTESTD() {
    TODO();
} //	Packed Bit Test Masks and Set Flags
InterruptRaisedOr<void> CPU::handle_KTESTQ() {
    TODO();
} //	Packed Bit Test Masks and Set Flags
InterruptRaisedOr<void> CPU::handle_KTESTW() {
    TODO();
} //	Packed Bit Test Masks and Set Flags
InterruptRaisedOr<void> CPU::handle_KUNPCKBW() {
    TODO();
} //	Unpack for Mask Registers
InterruptRaisedOr<void> CPU::handle_KUNPCKDQ() {
    TODO();
} //	Unpack for Mask Registers
InterruptRaisedOr<void> CPU::handle_KUNPCKWD() {
    TODO();
} //	Unpack for Mask Registers
InterruptRaisedOr<void> CPU::handle_KXNORB() {
    TODO();
} //	Bitwise Logical XNOR Masks
InterruptRaisedOr<void> CPU::handle_KXNORD() {
    TODO();
} //	Bitwise Logical XNOR Masks
InterruptRaisedOr<void> CPU::handle_KXNORQ() {
    TODO();
} //	Bitwise Logical XNOR Masks
InterruptRaisedOr<void> CPU::handle_KXNORW() {
    TODO();
} //	Bitwise Logical XNOR Masks
InterruptRaisedOr<void> CPU::handle_KXORB() {
    TODO();
} //	Bitwise Logical XOR Masks
InterruptRaisedOr<void> CPU::handle_KXORD() {
    TODO();
} //	Bitwise Logical XOR Masks
InterruptRaisedOr<void> CPU::handle_KXORQ() {
    TODO();
} //	Bitwise Logical XOR Masks
InterruptRaisedOr<void> CPU::handle_KXORW() {
    TODO();
} //	Bitwise Logical XOR Masks
InterruptRaisedOr<void> CPU::handle_LAHF() {
    TODO();
} //	Load Status Flags Into AH Register
InterruptRaisedOr<void> CPU::handle_LAR() {
    TODO();
} //	Load Access Rights Byte
InterruptRaisedOr<void> CPU::handle_LDDQU() {
    TODO();
} //	Load Unaligned Integer 128 Bits
InterruptRaisedOr<void> CPU::handle_LDMXCSR() {
    TODO();
} //	Load MXCSR Register
InterruptRaisedOr<void> CPU::handle_LDS() {
    TODO();
} //	Load Far Pointer
InterruptRaisedOr<void> CPU::handle_LDTILECFG() {
    TODO();
} //	Load Tile Configuration
InterruptRaisedOr<void> CPU::handle_LEA() {
    TODO();
} //	Load Effective Address
InterruptRaisedOr<void> CPU::handle_LEAVE() {
    TODO();
} //	High Level Procedure Exit
InterruptRaisedOr<void> CPU::handle_LES() {
    TODO();
} //	Load Far Pointer
InterruptRaisedOr<void> CPU::handle_LFENCE() {
    TODO();
} //	Load Fence
InterruptRaisedOr<void> CPU::handle_LFS() {
    TODO();
} //	Load Far Pointer
InterruptRaisedOr<void> CPU::handle_LGDT() {
    TODO();
} //	Load Global/Interrupt Descriptor Table Register
InterruptRaisedOr<void> CPU::handle_LGS() {
    TODO();
} //	Load Far Pointer
InterruptRaisedOr<void> CPU::handle_LIDT() {
    TODO();
} //	Load Global/Interrupt Descriptor Table Register
InterruptRaisedOr<void> CPU::handle_LLDT() {
    TODO();
} //	Load Local Descriptor Table Register
InterruptRaisedOr<void> CPU::handle_LMSW() {
    TODO();
} //	Load Machine Status Word
InterruptRaisedOr<void> CPU::handle_LOADIWKEY() {
    TODO();
} //	Load Internal Wrapping Key With Key Locker
InterruptRaisedOr<void> CPU::handle_LOCK() {
    TODO();
} //	Assert LOCK# Signal Prefix
InterruptRaisedOr<void> CPU::handle_LODS() {
    TODO();
} //	Load String
InterruptRaisedOr<void> CPU::handle_LODSB() {
    TODO();
} //	Load String
InterruptRaisedOr<void> CPU::handle_LODSD() {
    TODO();
} //	Load String
InterruptRaisedOr<void> CPU::handle_LODSQ() {
    TODO();
} //	Load String
InterruptRaisedOr<void> CPU::handle_LODSW() {
    TODO();
} //	Load String
InterruptRaisedOr<void> CPU::handle_LOOP() {
    TODO();
} //	Loop According to ECX Counter
InterruptRaisedOr<void> CPU::handle_LOOPcc() {
    TODO();
} //	Loop According to ECX Counter
InterruptRaisedOr<void> CPU::handle_LSL() {
    TODO();
} //	Load Segment Limit
InterruptRaisedOr<void> CPU::handle_LSS() {
    TODO();
} //	Load Far Pointer
InterruptRaisedOr<void> CPU::handle_LTR() {
    TODO();
} //	Load Task Register
InterruptRaisedOr<void> CPU::handle_LZCNT() {
    TODO();
} //	Count the Number of Leading Zero Bits
InterruptRaisedOr<void> CPU::handle_MASKMOVDQU() {
    TODO();
} //	Store Selected Bytes of Double Quadword
InterruptRaisedOr<void> CPU::handle_MASKMOVQ() {
    TODO();
} //	Store Selected Bytes of Quadword
InterruptRaisedOr<void> CPU::handle_MAXPD() {
    TODO();
} //	Maximum of Packed Double Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_MAXPS() {
    TODO();
} //	Maximum of Packed Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_MAXSD() {
    TODO();
} //	Return Maximum Scalar Double Precision Floating-Point Value
InterruptRaisedOr<void> CPU::handle_MAXSS() {
    TODO();
} //	Return Maximum Scalar Single Precision Floating-Point Value
InterruptRaisedOr<void> CPU::handle_MFENCE() {
    TODO();
} //	Memory Fence
InterruptRaisedOr<void> CPU::handle_MINPD() {
    TODO();
} //	Minimum of Packed Double Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_MINPS() {
    TODO();
} //	Minimum of Packed Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_MINSD() {
    TODO();
} //	Return Minimum Scalar Double Precision Floating-Point Value
InterruptRaisedOr<void> CPU::handle_MINSS() {
    TODO();
} //	Return Minimum Scalar Single Precision Floating-Point Value
InterruptRaisedOr<void> CPU::handle_MONITOR() {
    TODO();
} //	Set Up Monitor Address
InterruptRaisedOr<void> CPU::handle_MOV() {
    /**
     * TODO:
     * Attempting to set any reserved bits
     * in CR0[31:0] is ignored. Attempting to set any reserved bits in CR0[63:32] results in a general-protection excep-
     * tion, #GP(0). When PCIDs are not enabled, bits 2:0 and bits 11:5 of CR3 are not used and attempts to set them
     * are ignored. Attempting to set any reserved bits in CR3[63:MAXPHYADDR] results in #GP(0). Attempting to set
     * any reserved bits in CR4 results in #GP(0).
     * Which reserved bit violations generate #GP(0) additionally:
     * Attempting to write a non-zero value into the reserved bits of the MXCSR register.
     * Writing to a reserved bit in an MSR.
     * If an attempt is made to set a reserved bit in CR3, CR4 or CR8.
     */
    TODO();
} //	Move
InterruptRaisedOr<void> CPU::handle_MOVAPD() {
    TODO();
} //	Move Aligned Packed Double Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_MOVAPS() {
    TODO();
} //	Move Aligned Packed Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_MOVBE() {
    TODO();
} //	Move Data After Swapping Bytes
InterruptRaisedOr<void> CPU::handle_MOVD() {
    TODO();
} //	Move Doubleword/Move Quadword
InterruptRaisedOr<void> CPU::handle_MOVDDUP() {
    TODO();
} //	Replicate Double Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_MOVDIR64B() {
    TODO();
} //	Move 64 Bytes as Direct Store
InterruptRaisedOr<void> CPU::handle_MOVDIRI() {
    TODO();
} //	Move Doubleword as Direct Store
InterruptRaisedOr<void> CPU::handle_MOVDQ2Q() {
    TODO();
} //	Move Quadword from XMM to MMX Technology Register
InterruptRaisedOr<void> CPU::handle_MOVDQA() {
    TODO();
} //	Move Aligned Packed Integer Values
InterruptRaisedOr<void> CPU::handle_MOVDQU() {
    TODO();
} //	Move Unaligned Packed Integer Values
InterruptRaisedOr<void> CPU::handle_MOVHLPS() {
    TODO();
} //	Move Packed Single Precision Floating-Point Values High to Low
InterruptRaisedOr<void> CPU::handle_MOVHPD() {
    TODO();
} //	Move High Packed Double Precision Floating-Point Value
InterruptRaisedOr<void> CPU::handle_MOVHPS() {
    TODO();
} //	Move High Packed Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_MOVLHPS() {
    TODO();
} //	Move Packed Single Precision Floating-Point Values Low to High
InterruptRaisedOr<void> CPU::handle_MOVLPD() {
    TODO();
} //	Move Low Packed Double Precision Floating-Point Value
InterruptRaisedOr<void> CPU::handle_MOVLPS() {
    TODO();
} //	Move Low Packed Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_MOVMSKPD() {
    TODO();
} //	Extract Packed Double Precision Floating-Point Sign Mask
InterruptRaisedOr<void> CPU::handle_MOVMSKPS() {
    TODO();
} //	Extract Packed Single Precision Floating-Point Sign Mask
InterruptRaisedOr<void> CPU::handle_MOVNTDQ() {
    TODO();
} //	Store Packed Integers Using Non-Temporal Hint
InterruptRaisedOr<void> CPU::handle_MOVNTDQA() {
    TODO();
} //	Load Double Quadword Non-Temporal Aligned Hint
InterruptRaisedOr<void> CPU::handle_MOVNTI() {
    TODO();
} //	Store Doubleword Using Non-Temporal Hint
InterruptRaisedOr<void> CPU::handle_MOVNTPD() {
    TODO();
} //	Store Packed Double Precision Floating-Point Values Using Non-Temporal Hint
InterruptRaisedOr<void> CPU::handle_MOVNTPS() {
    TODO();
} //	Store Packed Single Precision Floating-Point Values Using Non-Temporal Hint
InterruptRaisedOr<void> CPU::handle_MOVNTQ() {
    TODO();
} //	Store of Quadword Using Non-Temporal Hint
InterruptRaisedOr<void> CPU::handle_MOVQ() {
    TODO();
} //	Move Doubleword/Move Quadword
InterruptRaisedOr<void> CPU::handle_MOVQ2DQ() {
    TODO();
} //	Move Quadword from MMX Technology to XMM Register
InterruptRaisedOr<void> CPU::handle_MOVS() {
    TODO();
} //	Move Data From String to String
InterruptRaisedOr<void> CPU::handle_MOVSB() {
    TODO();
} //	Move Data From String to String
InterruptRaisedOr<void> CPU::handle_MOVSD() {
    TODO();
} //	Move Data From String to String
InterruptRaisedOr<void> CPU::handle_MOVSHDUP() {
    TODO();
} //	Replicate Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_MOVSLDUP() {
    TODO();
} //	Replicate Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_MOVSQ() {
    TODO();
} //	Move Data From String to String
InterruptRaisedOr<void> CPU::handle_MOVSS() {
    TODO();
} //	Move or Merge Scalar Single Precision Floating-Point Value
InterruptRaisedOr<void> CPU::handle_MOVSW() {
    TODO();
} //	Move Data From String to String
InterruptRaisedOr<void> CPU::handle_MOVSX() {
    TODO();
} //	Move With Sign-Extension
InterruptRaisedOr<void> CPU::handle_MOVSXD() {
    TODO();
} //	Move With Sign-Extension
InterruptRaisedOr<void> CPU::handle_MOVUPD() {
    TODO();
} //	Move Unaligned Packed Double Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_MOVUPS() {
    TODO();
} //	Move Unaligned Packed Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_MOVZX() {
    TODO();
} //	Move With Zero-Extend
InterruptRaisedOr<void> CPU::handle_MPSADBW() {
    TODO();
} //	Compute Multiple Packed Sums of Absolute Difference
InterruptRaisedOr<void> CPU::handle_MUL() {
    TODO();
} //	Unsigned Multiply
InterruptRaisedOr<void> CPU::handle_MULPD() {
    TODO();
} //	Multiply Packed Double Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_MULPS() {
    TODO();
} //	Multiply Packed Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_MULSD() {
    TODO();
} //	Multiply Scalar Double Precision Floating-Point Value
InterruptRaisedOr<void> CPU::handle_MULSS() {
    TODO();
} //	Multiply Scalar Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_MULX() {
    TODO();
} //	Unsigned Multiply Without Affecting Flags
InterruptRaisedOr<void> CPU::handle_MWAIT() {
    TODO();
} //	Monitor Wait
InterruptRaisedOr<void> CPU::handle_NEG() {
    TODO();
} //	Two's Complement Negation
InterruptRaisedOr<void> CPU::handle_NOP() {
    TODO();
} //	No Operation
InterruptRaisedOr<void> CPU::handle_NOT() {
    TODO();
} //	One's Complement Negation
InterruptRaisedOr<void> CPU::handle_OR() {
    TODO();
} //	Logical Inclusive OR
InterruptRaisedOr<void> CPU::handle_ORPD() {
    TODO();
} //	Bitwise Logical OR of Packed Double Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_ORPS() {
    TODO();
} //	Bitwise Logical OR of Packed Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_OUT() {
    TODO();
} //	Output to Port
InterruptRaisedOr<void> CPU::handle_OUTS() {
    TODO();
} //	Output String to Port
InterruptRaisedOr<void> CPU::handle_OUTSB() {
    TODO();
} //	Output String to Port
InterruptRaisedOr<void> CPU::handle_OUTSD() {
    TODO();
} //	Output String to Port
InterruptRaisedOr<void> CPU::handle_OUTSW() {
    TODO();
} //	Output String to Port
InterruptRaisedOr<void> CPU::handle_PABSB() {
    TODO();
} //	Packed Absolute Value
InterruptRaisedOr<void> CPU::handle_PABSD() {
    TODO();
} //	Packed Absolute Value
InterruptRaisedOr<void> CPU::handle_PABSQ() {
    TODO();
} //	Packed Absolute Value
InterruptRaisedOr<void> CPU::handle_PABSW() {
    TODO();
} //	Packed Absolute Value
InterruptRaisedOr<void> CPU::handle_PACKSSDW() {
    TODO();
} //	Pack With Signed Saturation
InterruptRaisedOr<void> CPU::handle_PACKSSWB() {
    TODO();
} //	Pack With Signed Saturation
InterruptRaisedOr<void> CPU::handle_PACKUSDW() {
    TODO();
} //	Pack With Unsigned Saturation
InterruptRaisedOr<void> CPU::handle_PACKUSWB() {
    TODO();
} //	Pack With Unsigned Saturation
InterruptRaisedOr<void> CPU::handle_PADDB() {
    TODO();
} //	Add Packed Integers
InterruptRaisedOr<void> CPU::handle_PADDD() {
    TODO();
} //	Add Packed Integers
InterruptRaisedOr<void> CPU::handle_PADDQ() {
    TODO();
} //	Add Packed Integers
InterruptRaisedOr<void> CPU::handle_PADDSB() {
    TODO();
} //	Add Packed Signed Integers with Signed Saturation
InterruptRaisedOr<void> CPU::handle_PADDSW() {
    TODO();
} //	Add Packed Signed Integers with Signed Saturation
InterruptRaisedOr<void> CPU::handle_PADDUSB() {
    TODO();
} //	Add Packed Unsigned Integers With Unsigned Saturation
InterruptRaisedOr<void> CPU::handle_PADDUSW() {
    TODO();
} //	Add Packed Unsigned Integers With Unsigned Saturation
InterruptRaisedOr<void> CPU::handle_PADDW() {
    TODO();
} //	Add Packed Integers
InterruptRaisedOr<void> CPU::handle_PALIGNR() {
    TODO();
} //	Packed Align Right
InterruptRaisedOr<void> CPU::handle_PAND() {
    TODO();
} //	Logical AND
InterruptRaisedOr<void> CPU::handle_PANDN() {
    TODO();
} //	Logical AND NOT
InterruptRaisedOr<void> CPU::handle_PAUSE() {
    TODO();
} //	Spin Loop Hint
InterruptRaisedOr<void> CPU::handle_PAVGB() {
    TODO();
} //	Average Packed Integers
InterruptRaisedOr<void> CPU::handle_PAVGW() {
    TODO();
} //	Average Packed Integers
InterruptRaisedOr<void> CPU::handle_PBLENDVB() {
    TODO();
} //	Variable Blend Packed Bytes
InterruptRaisedOr<void> CPU::handle_PBLENDW() {
    TODO();
} //	Blend Packed Words
InterruptRaisedOr<void> CPU::handle_PCLMULQDQ() {
    TODO();
} //	Carry-Less Multiplication Quadword
InterruptRaisedOr<void> CPU::handle_PCMPEQB() {
    TODO();
} //	Compare Packed Data for Equal
InterruptRaisedOr<void> CPU::handle_PCMPEQD() {
    TODO();
} //	Compare Packed Data for Equal
InterruptRaisedOr<void> CPU::handle_PCMPEQQ() {
    TODO();
} //	Compare Packed Qword Data for Equal
InterruptRaisedOr<void> CPU::handle_PCMPEQW() {
    TODO();
} //	Compare Packed Data for Equal
InterruptRaisedOr<void> CPU::handle_PCMPESTRI() {
    TODO();
} //	Packed Compare Explicit Length Strings, Return Index
InterruptRaisedOr<void> CPU::handle_PCMPESTRM() {
    TODO();
} //	Packed Compare Explicit Length Strings, Return Mask
InterruptRaisedOr<void> CPU::handle_PCMPGTB() {
    TODO();
} //	Compare Packed Signed Integers for Greater Than
InterruptRaisedOr<void> CPU::handle_PCMPGTD() {
    TODO();
} //	Compare Packed Signed Integers for Greater Than
InterruptRaisedOr<void> CPU::handle_PCMPGTQ() {
    TODO();
} //	Compare Packed Data for Greater Than
InterruptRaisedOr<void> CPU::handle_PCMPGTW() {
    TODO();
} //	Compare Packed Signed Integers for Greater Than
InterruptRaisedOr<void> CPU::handle_PCMPISTRI() {
    TODO();
} //	Packed Compare Implicit Length Strings, Return Index
InterruptRaisedOr<void> CPU::handle_PCMPISTRM() {
    TODO();
} //	Packed Compare Implicit Length Strings, Return Mask
InterruptRaisedOr<void> CPU::handle_PCONFIG() {
    TODO();
} //	Platform Configuration
InterruptRaisedOr<void> CPU::handle_PDEP() {
    TODO();
} //	Parallel Bits Deposit
InterruptRaisedOr<void> CPU::handle_PEXT() {
    TODO();
} //	Parallel Bits Extract
InterruptRaisedOr<void> CPU::handle_PEXTRB() {
    TODO();
} //	Extract Byte/Dword/Qword
InterruptRaisedOr<void> CPU::handle_PEXTRD() {
    TODO();
} //	Extract Byte/Dword/Qword
InterruptRaisedOr<void> CPU::handle_PEXTRQ() {
    TODO();
} //	Extract Byte/Dword/Qword
InterruptRaisedOr<void> CPU::handle_PEXTRW() {
    TODO();
} //	Extract Word
InterruptRaisedOr<void> CPU::handle_PHADDD() {
    TODO();
} //	Packed Horizontal Add
InterruptRaisedOr<void> CPU::handle_PHADDSW() {
    TODO();
} //	Packed Horizontal Add and Saturate
InterruptRaisedOr<void> CPU::handle_PHADDW() {
    TODO();
} //	Packed Horizontal Add
InterruptRaisedOr<void> CPU::handle_PHMINPOSUW() {
    TODO();
} //	Packed Horizontal Word Minimum
InterruptRaisedOr<void> CPU::handle_PHSUBD() {
    TODO();
} //	Packed Horizontal Subtract
InterruptRaisedOr<void> CPU::handle_PHSUBSW() {
    TODO();
} //	Packed Horizontal Subtract and Saturate
InterruptRaisedOr<void> CPU::handle_PHSUBW() {
    TODO();
} //	Packed Horizontal Subtract
InterruptRaisedOr<void> CPU::handle_PINSRB() {
    TODO();
} //	Insert Byte/Dword/Qword
InterruptRaisedOr<void> CPU::handle_PINSRD() {
    TODO();
} //	Insert Byte/Dword/Qword
InterruptRaisedOr<void> CPU::handle_PINSRQ() {
    TODO();
} //	Insert Byte/Dword/Qword
InterruptRaisedOr<void> CPU::handle_PINSRW() {
    TODO();
} //	Insert Word
InterruptRaisedOr<void> CPU::handle_PMADDUBSW() {
    TODO();
} //	Multiply and Add Packed Signed and Unsigned Bytes
InterruptRaisedOr<void> CPU::handle_PMADDWD() {
    TODO();
} //	Multiply and Add Packed Integers
InterruptRaisedOr<void> CPU::handle_PMAXSB() {
    TODO();
} //	Maximum of Packed Signed Integers
InterruptRaisedOr<void> CPU::handle_PMAXSD() {
    TODO();
} //	Maximum of Packed Signed Integers
InterruptRaisedOr<void> CPU::handle_PMAXSQ() {
    TODO();
} //	Maximum of Packed Signed Integers
InterruptRaisedOr<void> CPU::handle_PMAXSW() {
    TODO();
} //	Maximum of Packed Signed Integers
InterruptRaisedOr<void> CPU::handle_PMAXUB() {
    TODO();
} //	Maximum of Packed Unsigned Integers
InterruptRaisedOr<void> CPU::handle_PMAXUD() {
    TODO();
} //	Maximum of Packed Unsigned Integers
InterruptRaisedOr<void> CPU::handle_PMAXUQ() {
    TODO();
} //	Maximum of Packed Unsigned Integers
InterruptRaisedOr<void> CPU::handle_PMAXUW() {
    TODO();
} //	Maximum of Packed Unsigned Integers
InterruptRaisedOr<void> CPU::handle_PMINSB() {
    TODO();
} //	Minimum of Packed Signed Integers
InterruptRaisedOr<void> CPU::handle_PMINSD() {
    TODO();
} //	Minimum of Packed Signed Integers
InterruptRaisedOr<void> CPU::handle_PMINSQ() {
    TODO();
} //	Minimum of Packed Signed Integers
InterruptRaisedOr<void> CPU::handle_PMINSW() {
    TODO();
} //	Minimum of Packed Signed Integers
InterruptRaisedOr<void> CPU::handle_PMINUB() {
    TODO();
} //	Minimum of Packed Unsigned Integers
InterruptRaisedOr<void> CPU::handle_PMINUD() {
    TODO();
} //	Minimum of Packed Unsigned Integers
InterruptRaisedOr<void> CPU::handle_PMINUQ() {
    TODO();
} //	Minimum of Packed Unsigned Integers
InterruptRaisedOr<void> CPU::handle_PMINUW() {
    TODO();
} //	Minimum of Packed Unsigned Integers
InterruptRaisedOr<void> CPU::handle_PMOVMSKB() {
    TODO();
} //	Move Byte Mask
InterruptRaisedOr<void> CPU::handle_PMOVSX() {
    TODO();
} //	Packed Move With Sign Extend
InterruptRaisedOr<void> CPU::handle_PMOVZX() {
    TODO();
} //	Packed Move With Zero Extend
InterruptRaisedOr<void> CPU::handle_PMULDQ() {
    TODO();
} //	Multiply Packed Doubleword Integers
InterruptRaisedOr<void> CPU::handle_PMULHRSW() {
    TODO();
} //	Packed Multiply High With Round and Scale
InterruptRaisedOr<void> CPU::handle_PMULHUW() {
    TODO();
} //	Multiply Packed Unsigned Integers and Store High Result
InterruptRaisedOr<void> CPU::handle_PMULHW() {
    TODO();
} //	Multiply Packed Signed Integers and Store High Result
InterruptRaisedOr<void> CPU::handle_PMULLD() {
    TODO();
} //	Multiply Packed Integers and Store Low Result
InterruptRaisedOr<void> CPU::handle_PMULLQ() {
    TODO();
} //	Multiply Packed Integers and Store Low Result
InterruptRaisedOr<void> CPU::handle_PMULLW() {
    TODO();
} //	Multiply Packed Signed Integers and Store Low Result
InterruptRaisedOr<void> CPU::handle_PMULUDQ() {
    TODO();
} //	Multiply Packed Unsigned Doubleword Integers
InterruptRaisedOr<void> CPU::handle_POP() {
    TODO();
} //	Pop a Value From the Stack
InterruptRaisedOr<void> CPU::handle_POPA() {
    TODO();
} //	Pop All General-Purpose Registers
InterruptRaisedOr<void> CPU::handle_POPAD() {
    TODO();
} //	Pop All General-Purpose Registers
InterruptRaisedOr<void> CPU::handle_POPCNT() {
    TODO();
} //	Return the Count of Number of Bits Set to 1
InterruptRaisedOr<void> CPU::handle_POPF() {
    TODO();
} //	Pop Stack Into EFLAGS Register
InterruptRaisedOr<void> CPU::handle_POPFD() {
    TODO();
} //	Pop Stack Into EFLAGS Register
InterruptRaisedOr<void> CPU::handle_POPFQ() {
    TODO();
} //	Pop Stack Into EFLAGS Register
InterruptRaisedOr<void> CPU::handle_POR() {
    TODO();
} //	Bitwise Logical OR
InterruptRaisedOr<void> CPU::handle_PREFETCHW() {
    TODO();
} //	Prefetch Data Into Caches in Anticipation of a Write
InterruptRaisedOr<void> CPU::handle_PREFETCHh() {
    TODO();
} //	Prefetch Data Into Caches
InterruptRaisedOr<void> CPU::handle_PSADBW() {
    TODO();
} //	Compute Sum of Absolute Differences
InterruptRaisedOr<void> CPU::handle_PSHUFB() {
    TODO();
} //	Packed Shuffle Bytes
InterruptRaisedOr<void> CPU::handle_PSHUFD() {
    TODO();
} //	Shuffle Packed Doublewords
InterruptRaisedOr<void> CPU::handle_PSHUFHW() {
    TODO();
} //	Shuffle Packed High Words
InterruptRaisedOr<void> CPU::handle_PSHUFLW() {
    TODO();
} //	Shuffle Packed Low Words
InterruptRaisedOr<void> CPU::handle_PSHUFW() {
    TODO();
} //	Shuffle Packed Words
InterruptRaisedOr<void> CPU::handle_PSIGNB() {
    TODO();
} //	Packed SIGN
InterruptRaisedOr<void> CPU::handle_PSIGND() {
    TODO();
} //	Packed SIGN
InterruptRaisedOr<void> CPU::handle_PSIGNW() {
    TODO();
} //	Packed SIGN
InterruptRaisedOr<void> CPU::handle_PSLLD() {
    TODO();
} //	Shift Packed Data Left Logical
InterruptRaisedOr<void> CPU::handle_PSLLDQ() {
    TODO();
} //	Shift Double Quadword Left Logical
InterruptRaisedOr<void> CPU::handle_PSLLQ() {
    TODO();
} //	Shift Packed Data Left Logical
InterruptRaisedOr<void> CPU::handle_PSLLW() {
    TODO();
} //	Shift Packed Data Left Logical
InterruptRaisedOr<void> CPU::handle_PSRAD() {
    TODO();
} //	Shift Packed Data Right Arithmetic
InterruptRaisedOr<void> CPU::handle_PSRAQ() {
    TODO();
} //	Shift Packed Data Right Arithmetic
InterruptRaisedOr<void> CPU::handle_PSRAW() {
    TODO();
} //	Shift Packed Data Right Arithmetic
InterruptRaisedOr<void> CPU::handle_PSRLD() {
    TODO();
} //	Shift Packed Data Right Logical
InterruptRaisedOr<void> CPU::handle_PSRLDQ() {
    TODO();
} //	Shift Double Quadword Right Logical
InterruptRaisedOr<void> CPU::handle_PSRLQ() {
    TODO();
} //	Shift Packed Data Right Logical
InterruptRaisedOr<void> CPU::handle_PSRLW() {
    TODO();
} //	Shift Packed Data Right Logical
InterruptRaisedOr<void> CPU::handle_PSUBB() {
    TODO();
} //	Subtract Packed Integers
InterruptRaisedOr<void> CPU::handle_PSUBD() {
    TODO();
} //	Subtract Packed Integers
InterruptRaisedOr<void> CPU::handle_PSUBQ() {
    TODO();
} //	Subtract Packed Quadword Integers
InterruptRaisedOr<void> CPU::handle_PSUBSB() {
    TODO();
} //	Subtract Packed Signed Integers With Signed Saturation
InterruptRaisedOr<void> CPU::handle_PSUBSW() {
    TODO();
} //	Subtract Packed Signed Integers With Signed Saturation
InterruptRaisedOr<void> CPU::handle_PSUBUSB() {
    TODO();
} //	Subtract Packed Unsigned Integers With Unsigned Saturation
InterruptRaisedOr<void> CPU::handle_PSUBUSW() {
    TODO();
} //	Subtract Packed Unsigned Integers With Unsigned Saturation
InterruptRaisedOr<void> CPU::handle_PSUBW() {
    TODO();
} //	Subtract Packed Integers
InterruptRaisedOr<void> CPU::handle_PTEST() {
    TODO();
} //	Logical Compare
InterruptRaisedOr<void> CPU::handle_PTWRITE() {
    TODO();
} //	Write Data to a Processor Trace Packet
InterruptRaisedOr<void> CPU::handle_PUNPCKHBW() {
    TODO();
} //	Unpack High Data
InterruptRaisedOr<void> CPU::handle_PUNPCKHDQ() {
    TODO();
} //	Unpack High Data
InterruptRaisedOr<void> CPU::handle_PUNPCKHQDQ() {
    TODO();
} //	Unpack High Data
InterruptRaisedOr<void> CPU::handle_PUNPCKHWD() {
    TODO();
} //	Unpack High Data
InterruptRaisedOr<void> CPU::handle_PUNPCKLBW() {
    TODO();
} //	Unpack Low Data
InterruptRaisedOr<void> CPU::handle_PUNPCKLDQ() {
    TODO();
} //	Unpack Low Data
InterruptRaisedOr<void> CPU::handle_PUNPCKLQDQ() {
    TODO();
} //	Unpack Low Data
InterruptRaisedOr<void> CPU::handle_PUNPCKLWD() {
    TODO();
} //	Unpack Low Data
InterruptRaisedOr<void> CPU::handle_PUSH() {
    TODO();
} //	Push Word, Doubleword, or Quadword Onto the Stack
InterruptRaisedOr<void> CPU::handle_PUSHA() {
    TODO();
} //	Push All General-Purpose Registers
InterruptRaisedOr<void> CPU::handle_PUSHAD() {
    TODO();
} //	Push All General-Purpose Registers
InterruptRaisedOr<void> CPU::handle_PUSHF() {
    TODO();
} //	Push EFLAGS Register Onto the Stack
InterruptRaisedOr<void> CPU::handle_PUSHFD() {
    TODO();
} //	Push EFLAGS Register Onto the Stack
InterruptRaisedOr<void> CPU::handle_PUSHFQ() {
    TODO();
} //	Push EFLAGS Register Onto the Stack
InterruptRaisedOr<void> CPU::handle_PXOR() {
    TODO();
} //	Logical Exclusive OR
InterruptRaisedOr<void> CPU::handle_RCL() {
    TODO();
} //	Rotate
InterruptRaisedOr<void> CPU::handle_RCPPS() {
    TODO();
} //	Compute Reciprocals of Packed Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_RCPSS() {
    TODO();
} //	Compute Reciprocal of Scalar Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_RCR() {
    TODO();
} //	Rotate
InterruptRaisedOr<void> CPU::handle_RDFSBASE() {
    TODO();
} //	Read FS/GS Segment Base
InterruptRaisedOr<void> CPU::handle_RDGSBASE() {
    TODO();
} //	Read FS/GS Segment Base
InterruptRaisedOr<void> CPU::handle_RDMSR() {
    TODO();
} //	Read From Model Specific Register
InterruptRaisedOr<void> CPU::handle_RDPID() {
    TODO();
} //	Read Processor ID
InterruptRaisedOr<void> CPU::handle_RDPKRU() {
    TODO();
} //	Read Protection Key Rights for User Pages
InterruptRaisedOr<void> CPU::handle_RDPMC() {
    TODO();
} //	Read Performance-Monitoring Counters
InterruptRaisedOr<void> CPU::handle_RDRAND() {
    TODO();
} //	Read Random Number
InterruptRaisedOr<void> CPU::handle_RDSEED() {
    TODO();
} //	Read Random SEED
InterruptRaisedOr<void> CPU::handle_RDSSPD() {
    TODO();
} //	Read Shadow Stack Pointer
InterruptRaisedOr<void> CPU::handle_RDSSPQ() {
    TODO();
} //	Read Shadow Stack Pointer
InterruptRaisedOr<void> CPU::handle_RDTSC() {
    TODO();
} //	Read Time-Stamp Counter
InterruptRaisedOr<void> CPU::handle_RDTSCP() {
    TODO();
} //	Read Time-Stamp Counter and Processor ID
InterruptRaisedOr<void> CPU::handle_REP() {
    TODO();
} //	Repeat String Operation Prefix
InterruptRaisedOr<void> CPU::handle_REPE() {
    TODO();
} //	Repeat String Operation Prefix
InterruptRaisedOr<void> CPU::handle_REPNE() {
    TODO();
} //	Repeat String Operation Prefix
InterruptRaisedOr<void> CPU::handle_REPNZ() {
    TODO();
} //	Repeat String Operation Prefix
InterruptRaisedOr<void> CPU::handle_REPZ() {
    TODO();
} //	Repeat String Operation Prefix
InterruptRaisedOr<void> CPU::handle_RET() {
    TODO();
} //	Return From Procedure
InterruptRaisedOr<void> CPU::handle_ROL() {
    TODO();
} //	Rotate
InterruptRaisedOr<void> CPU::handle_ROR() {
    TODO();
} //	Rotate
InterruptRaisedOr<void> CPU::handle_RORX() {
    TODO();
} //	Rotate Right Logical Without Affecting Flags
InterruptRaisedOr<void> CPU::handle_ROUNDPD() {
    TODO();
} //	Round Packed Double Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_ROUNDPS() {
    TODO();
} //	Round Packed Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_ROUNDSD() {
    TODO();
} //	Round Scalar Double Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_ROUNDSS() {
    TODO();
} //	Round Scalar Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_RSM() {
    TODO();
} //	Resume From System Management Mode
InterruptRaisedOr<void> CPU::handle_RSQRTPS() {
    TODO();
} //	Compute Reciprocals of Square Roots of Packed Single Precision Floating-PointValues
InterruptRaisedOr<void> CPU::handle_RSQRTSS() {
    TODO();
} //	Compute Reciprocal of Square Root of Scalar Single Precision Floating-Point Value
InterruptRaisedOr<void> CPU::handle_RSTORSSP() {
    TODO();
} //	Restore Saved Shadow Stack Pointer
InterruptRaisedOr<void> CPU::handle_SAHF() {
    TODO();
} //	Store AH Into Flags
InterruptRaisedOr<void> CPU::handle_SAL() {
    TODO();
} //	Shift
InterruptRaisedOr<void> CPU::handle_SAR() {
    TODO();
} //	Shift
InterruptRaisedOr<void> CPU::handle_SARX() {
    TODO();
} //	Shift Without Affecting Flags
InterruptRaisedOr<void> CPU::handle_SAVEPREVSSP() {
    TODO();
} //	Save Previous Shadow Stack Pointer
InterruptRaisedOr<void> CPU::handle_SBB() {
    TODO();
} //	Integer Subtraction With Borrow
InterruptRaisedOr<void> CPU::handle_SCAS() {
    TODO();
} //	Scan String
InterruptRaisedOr<void> CPU::handle_SCASB() {
    TODO();
} //	Scan String
InterruptRaisedOr<void> CPU::handle_SCASD() {
    TODO();
} //	Scan String
InterruptRaisedOr<void> CPU::handle_SCASW() {
    TODO();
} //	Scan String
InterruptRaisedOr<void> CPU::handle_SENDUIPI() {
    TODO();
} //	Send User Interprocessor Interrupt
InterruptRaisedOr<void> CPU::handle_SERIALIZE() {
    TODO();
} //	Serialize Instruction Execution
InterruptRaisedOr<void> CPU::handle_SETSSBSY() {
    TODO();
} //	Mark Shadow Stack Busy
InterruptRaisedOr<void> CPU::handle_SETcc() {
    TODO();
} //	Set Byte on Condition
InterruptRaisedOr<void> CPU::handle_SFENCE() {
    TODO();
} //	Store Fence
InterruptRaisedOr<void> CPU::handle_SGDT() {
    TODO();
} //	Store Global Descriptor Table Register
InterruptRaisedOr<void> CPU::handle_SHA1MSG1() {
    TODO();
} //	Perform an Intermediate Calculation for the Next Four SHA1 Message Dwords
InterruptRaisedOr<void> CPU::handle_SHA1MSG2() {
    TODO();
} //	Perform a Final Calculation for the Next Four SHA1 Message Dwords
InterruptRaisedOr<void> CPU::handle_SHA1NEXTE() {
    TODO();
} //	Calculate SHA1 State Variable E After Four Rounds
InterruptRaisedOr<void> CPU::handle_SHA1RNDS4() {
    TODO();
} //	Perform Four Rounds of SHA1 Operation
InterruptRaisedOr<void> CPU::handle_SHA256MSG1() {
    TODO();
} //	Perform an Intermediate Calculation for the Next Four SHA256 MessageDwords
InterruptRaisedOr<void> CPU::handle_SHA256MSG2() {
    TODO();
} //	Perform a Final Calculation for the Next Four SHA256 Message Dwords
InterruptRaisedOr<void> CPU::handle_SHA256RNDS2() {
    TODO();
} //	Perform Two Rounds of SHA256 Operation
InterruptRaisedOr<void> CPU::handle_SHL() {
    TODO();
} //	Shift
InterruptRaisedOr<void> CPU::handle_SHLD() {
    TODO();
} //	Double Precision Shift Left
InterruptRaisedOr<void> CPU::handle_SHLX() {
    TODO();
} //	Shift Without Affecting Flags
InterruptRaisedOr<void> CPU::handle_SHR() {
    TODO();
} //	Shift
InterruptRaisedOr<void> CPU::handle_SHRD() {
    TODO();
} //	Double Precision Shift Right
InterruptRaisedOr<void> CPU::handle_SHRX() {
    TODO();
} //	Shift Without Affecting Flags
InterruptRaisedOr<void> CPU::handle_SHUFPD() {
    TODO();
} //	Packed Interleave Shuffle of Pairs of Double Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_SHUFPS() {
    TODO();
} //	Packed Interleave Shuffle of Quadruplets of Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_SIDT() {
    TODO();
} //	Store Interrupt Descriptor Table Register
InterruptRaisedOr<void> CPU::handle_SLDT() {
    TODO();
} //	Store Local Descriptor Table Register
InterruptRaisedOr<void> CPU::handle_SMSW() {
    TODO();
} //	Store Machine Status Word
InterruptRaisedOr<void> CPU::handle_SQRTPD() {
    TODO();
} //	Square Root of Double Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_SQRTPS() {
    TODO();
} //	Square Root of Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_SQRTSD() {
    TODO();
} //	Compute Square Root of Scalar Double Precision Floating-Point Value
InterruptRaisedOr<void> CPU::handle_SQRTSS() {
    TODO();
} //	Compute Square Root of Scalar Single Precision Value
InterruptRaisedOr<void> CPU::handle_STAC() {
    TODO();
} //	Set AC Flag in EFLAGS Register
InterruptRaisedOr<void> CPU::handle_STC() {
    TODO();
} //	Set Carry Flag
InterruptRaisedOr<void> CPU::handle_STD() {
    TODO();
} //	Set Direction Flag
InterruptRaisedOr<void> CPU::handle_STI() {
    TODO();
} //	Set Interrupt Flag
InterruptRaisedOr<void> CPU::handle_STMXCSR() {
    TODO();
} //	Store MXCSR Register State
InterruptRaisedOr<void> CPU::handle_STOS() {
    TODO();
} //	Store String
InterruptRaisedOr<void> CPU::handle_STOSB() {
    TODO();
} //	Store String
InterruptRaisedOr<void> CPU::handle_STOSD() {
    TODO();
} //	Store String
InterruptRaisedOr<void> CPU::handle_STOSQ() {
    TODO();
} //	Store String
InterruptRaisedOr<void> CPU::handle_STOSW() {
    TODO();
} //	Store String
InterruptRaisedOr<void> CPU::handle_STR() {
    TODO();
} //	Store Task Register
InterruptRaisedOr<void> CPU::handle_STTILECFG() {
    TODO();
} //	Store Tile Configuration
InterruptRaisedOr<void> CPU::handle_STUI() {
    TODO();
} //	Set User Interrupt Flag
InterruptRaisedOr<void> CPU::handle_SUB() {
    TODO();
} //	Subtract
InterruptRaisedOr<void> CPU::handle_SUBPD() {
    TODO();
} //	Subtract Packed Double Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_SUBPS() {
    TODO();
} //	Subtract Packed Single Precision Floating-Point Values
InterruptRaisedOr<void> CPU::handle_SUBSD() {
    TODO();
} //	Subtract Scalar Double Precision Floating-Point Value
InterruptRaisedOr<void> CPU::handle_SUBSS() {
    TODO();
} //	Subtract Scalar Single Precision Floating-Point Value
InterruptRaisedOr<void> CPU::handle_SWAPGS() {
    TODO();
} //	Swap GS Base Register
InterruptRaisedOr<void> CPU::handle_SYSCALL() {
    TODO();
} //	Fast System Call
InterruptRaisedOr<void> CPU::handle_SYSENTER() {
    TODO();
} //	Fast System Call
InterruptRaisedOr<void> CPU::handle_SYSEXIT() {
    TODO();
} //	Fast Return from Fast System Call
InterruptRaisedOr<void> CPU::handle_SYSRET() {
    TODO();
} //	Return From Fast System Call
InterruptRaisedOr<void> CPU::handle_TDPBF16PS() {
    TODO();
} //	Dot Product of BF16 Tiles Accumulated into Packed Single Precision Tile
InterruptRaisedOr<void> CPU::handle_TDPBSSD() {
    TODO();
} //	Dot Product of Signed/Unsigned Bytes with DwordAccumulation
InterruptRaisedOr<void> CPU::handle_TDPBSUD() {
    TODO();
} //	Dot Product of Signed/Unsigned Bytes with DwordAccumulation
InterruptRaisedOr<void> CPU::handle_TDPBUSD() {
    TODO();
} //	Dot Product of Signed/Unsigned Bytes with DwordAccumulation
InterruptRaisedOr<void> CPU::handle_TDPBUUD() {
    TODO();
} //	Dot Product of Signed/Unsigned Bytes with DwordAccumulation
InterruptRaisedOr<void> CPU::handle_TEST() {
    TODO();
} //	Logical Compare
InterruptRaisedOr<void> CPU::handle_TESTUI() {
    TODO();
} //	Determine User Interrupt Flag
InterruptRaisedOr<void> CPU::handle_TILELOADD() {
    TODO();
} //	Load Tile
InterruptRaisedOr<void> CPU::handle_TILERELEASE() {
    TODO();
} //	Release Tile
InterruptRaisedOr<void> CPU::handle_TILESTORED() {
    TODO();
} //	Store Tile
InterruptRaisedOr<void> CPU::handle_TILEZERO() {
    TODO();
} //	Zero Tile
InterruptRaisedOr<void> CPU::handle_TPAUSE() {
    TODO();
} //	Timed PAUSE
InterruptRaisedOr<void> CPU::handle_TZCNT() {
    TODO();
} //	Count the Number of Trailing Zero Bits
InterruptRaisedOr<void> CPU::handle_UCOMISD() {
    TODO();
} //	Unordered Compare Scalar Double Precision Floating-Point Values and Set EFLAGS
InterruptRaisedOr<void> CPU::handle_UCOMISS() {
    TODO();
} //	Unordered Compare Scalar Single Precision Floating-Point Values and Set EFLAGS
InterruptRaisedOr<void> CPU::handle_UD() {
    TODO();
} //	Undefined Instruction
InterruptRaisedOr<void> CPU::handle_UIRET() {
    TODO();
} //


}