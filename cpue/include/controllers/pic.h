#pragma once

#include <optional>
#include <queue>
#include <bitset>

#include "common.h"
#include "forward.h"
#include "interrupts.h"

namespace CPUE {


/**
 * Programmable Interrupt Controller
 *
 * NOTE: WE CURRENTLY DON'T SUPPORT PIC
 *
 *
 * Is only responsible for interrupts generated by external devices such as
 *  - watchdog timers (although some watchdogs can also use the NMI pin and bypass the PIC)
 *  - keyboards
 *  - hard drives
 *  - etc.
 *
 *
 * PICs typically have a common set of registers:
 *  - interrupt request register (IRR),
 *  - in-service register (ISR),
 *  - and interrupt mask register (IMR).
 * The IRR specifies which interrupts are pending acknowledgement.
 * The ISR register specifies which interrupts have been acknowledged, but are still waiting for an end of interrupt (EOI).
 * The IMR specifies which interrupts are to be ignored and not acknowledged.
 * A simple register schema such as this allows up to two distinct interrupt requests to be outstanding at one time,
 * one waiting for acknowledgement, and one waiting for EOI.
 *
 * NOTE: The masking functionality is integrated into the interrupt controller, so masked interrupts do not reach the CPU at all.
 *
 * NOTE: By design PIC won't raise another interrupt until the CPU acknowledged the current interrupt.
 *
 * NOTE:
 * Once the interrupt is acknowledged by the CPU the interrupt controller can request another interrupt,
 * regardless if the CPU finished handled the previous interrupt or not.
 * Thus, depending on how the OS controls the CPU it is possible to have nested interrupts.
 *
 * When a device connected to one of the PIC's IRQ lines needs CPU attention the following flow happens:
 * 1. When the PIC receives an unmasked interrupt from a device (PIC interrupts
 *    are edge-triggered with high pin polarity), it sets the corresponding bit in its
 *    IRR (interrupt request register)
 * 2. The IRQ is dispatched to the CPU
 *    2.1 PIC converts the IRQ into a vector number and writes it to a port for CPU to read
 *    2.2 PIC raises an interrupt on CPU INTR pin
 *    2.3 PIC waits for CPU to acknowledge an interrupt before raising another interrupt
 * 3. The CPU acknowledges the IRQ.
 * 4. The PIC sets the corresponding bit in its ISR (in-service register) and clears the
 *    previously set bit in the IRR. If the same interrupt occurs again, it can now
 *    be queued a single time in the IRR.
 * 5. When the interrupt is being handled by the OS, it sends an EOI to the PIC,
 *    which clears the corresponding bit in the ISR
 *
 * When an interrupt is acknowledged the highest priority request is determined and its vector placed on
 * the bus. Additionally, a bit of the Interrupt Service register (ISO-7) is set. This bit remains set until the
 * microprocessor issues an End of Interrupt (EOI) command immediately before returning from the
 * service routine, or if AEOI (Automatic End of Interrupt) bit is set, until the trailing edge of the last INTA.
 *
 * To signal that an interrupt is being handled by the software, the interrupt controller receives an EOI (end of interrupt) notice from the OS.
 *
 * Most architectures also support interrupt priorities. When this is enabled,
 * it permits interrupt nesting only for those interrupts that have a higher priority than the current priority level.
 *
 */


constexpr u8 PIC_NUM_IRQ_PINS = 8;
constexpr u8 PIC_IRQ_VEC_BASE = 0xc0;

class PICConnectionHandle {
public:
    explicit PICConnectionHandle(u8 pin) : m_pin(pin) { CPUE_ASSERT(m_pin < PIC_NUM_IRQ_PINS, "Invalid pin number"); }
    u8 pin() const { return m_pin; }

private:
    u8 m_pin;
};

class PIC {
public:
    explicit PIC(ICU* icu) : m_icu(icu){};
    PIC(PIC const&) = delete;

    std::optional<PICConnectionHandle> request_connection() {
        if (m_next_free_pin >= PIC_NUM_IRQ_PINS)
            return {};
        return PICConnectionHandle(m_next_free_pin++);
    }

    void mask_pin(u8 pin);
    void unmask_pin(u8 pin);
    void raise_irq_pin(PICConnectionHandle const& handle);
    void clear_irq_pin(PICConnectionHandle const& handle);

private:
    void process_pending_irqs();

private:
    u8 m_next_free_pin = 0;
    std::bitset<PIC_NUM_IRQ_PINS> m_imr = 0; // Interrupt-Masking Register
    std::bitset<PIC_NUM_IRQ_PINS> m_isr = 0; // In-Service Register
    std::bitset<PIC_NUM_IRQ_PINS> m_irr = 0; // In-Request Register

    ICU* m_icu = nullptr;
};

}